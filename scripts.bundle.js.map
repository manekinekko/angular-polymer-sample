{"version":3,"sources":["webpack:///./~/webcomponents.js/webcomponents.js?5ee1","webpack:///./~/webcomponents.js/webcomponents.js","webpack:///./~/script-loader/addScript.js"],"names":[],"mappings":"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","file":"scripts.bundle.js","sourcesContent":["require(\"!!/Users/wassimchegham/Sandbox/oss/angular-polymer-sample/node_modules/script-loader/addScript.js\")(require(\"!!/Users/wassimchegham/Sandbox/oss/angular-polymer-sample/node_modules/raw-loader/index.js!/Users/wassimchegham/Sandbox/oss/angular-polymer-sample/node_modules/webcomponents.js/webcomponents.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./~/webcomponents.js/webcomponents.js\n// module id = 333\n// module chunks = 3","module.exports = \"/**\\n * @license\\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n// @version 0.7.24\\n(function() {\\n  window.WebComponents = window.WebComponents || {\\n    flags: {}\\n  };\\n  var file = \\\"webcomponents.js\\\";\\n  var script = document.querySelector('script[src*=\\\"' + file + '\\\"]');\\n  var flags = {};\\n  if (!flags.noOpts) {\\n    location.search.slice(1).split(\\\"&\\\").forEach(function(option) {\\n      var parts = option.split(\\\"=\\\");\\n      var match;\\n      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\\n        flags[match[1]] = parts[1] || true;\\n      }\\n    });\\n    if (script) {\\n      for (var i = 0, a; a = script.attributes[i]; i++) {\\n        if (a.name !== \\\"src\\\") {\\n          flags[a.name] = a.value || true;\\n        }\\n      }\\n    }\\n    if (flags.log && flags.log.split) {\\n      var parts = flags.log.split(\\\",\\\");\\n      flags.log = {};\\n      parts.forEach(function(f) {\\n        flags.log[f] = true;\\n      });\\n    } else {\\n      flags.log = {};\\n    }\\n  }\\n  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\\n  if (flags.shadow === \\\"native\\\") {\\n    flags.shadow = false;\\n  } else {\\n    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\\n  }\\n  if (flags.register) {\\n    window.CustomElements = window.CustomElements || {\\n      flags: {}\\n    };\\n    window.CustomElements.flags.register = flags.register;\\n  }\\n  WebComponents.flags = flags;\\n})();\\n\\nif (WebComponents.flags.shadow) {\\n  if (typeof WeakMap === \\\"undefined\\\") {\\n    (function() {\\n      var defineProperty = Object.defineProperty;\\n      var counter = Date.now() % 1e9;\\n      var WeakMap = function() {\\n        this.name = \\\"__st\\\" + (Math.random() * 1e9 >>> 0) + (counter++ + \\\"__\\\");\\n      };\\n      WeakMap.prototype = {\\n        set: function(key, value) {\\n          var entry = key[this.name];\\n          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\\n            value: [ key, value ],\\n            writable: true\\n          });\\n          return this;\\n        },\\n        get: function(key) {\\n          var entry;\\n          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\\n        },\\n        \\\"delete\\\": function(key) {\\n          var entry = key[this.name];\\n          if (!entry || entry[0] !== key) return false;\\n          entry[0] = entry[1] = undefined;\\n          return true;\\n        },\\n        has: function(key) {\\n          var entry = key[this.name];\\n          if (!entry) return false;\\n          return entry[0] === key;\\n        }\\n      };\\n      window.WeakMap = WeakMap;\\n    })();\\n  }\\n  window.ShadowDOMPolyfill = {};\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var constructorTable = new WeakMap();\\n    var nativePrototypeTable = new WeakMap();\\n    var wrappers = Object.create(null);\\n    function detectEval() {\\n      if (typeof chrome !== \\\"undefined\\\" && chrome.app && chrome.app.runtime) {\\n        return false;\\n      }\\n      if (navigator.getDeviceStorage) {\\n        return false;\\n      }\\n      try {\\n        var f = new Function(\\\"return true;\\\");\\n        return f();\\n      } catch (ex) {\\n        return false;\\n      }\\n    }\\n    var hasEval = detectEval();\\n    function assert(b) {\\n      if (!b) throw new Error(\\\"Assertion failed\\\");\\n    }\\n    var defineProperty = Object.defineProperty;\\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\\n    function mixin(to, from) {\\n      var names = getOwnPropertyNames(from);\\n      for (var i = 0; i < names.length; i++) {\\n        var name = names[i];\\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\\n      }\\n      return to;\\n    }\\n    function mixinStatics(to, from) {\\n      var names = getOwnPropertyNames(from);\\n      for (var i = 0; i < names.length; i++) {\\n        var name = names[i];\\n        switch (name) {\\n         case \\\"arguments\\\":\\n         case \\\"caller\\\":\\n         case \\\"length\\\":\\n         case \\\"name\\\":\\n         case \\\"prototype\\\":\\n         case \\\"toString\\\":\\n          continue;\\n        }\\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\\n      }\\n      return to;\\n    }\\n    function oneOf(object, propertyNames) {\\n      for (var i = 0; i < propertyNames.length; i++) {\\n        if (propertyNames[i] in object) return propertyNames[i];\\n      }\\n    }\\n    var nonEnumerableDataDescriptor = {\\n      value: undefined,\\n      configurable: true,\\n      enumerable: false,\\n      writable: true\\n    };\\n    function defineNonEnumerableDataProperty(object, name, value) {\\n      nonEnumerableDataDescriptor.value = value;\\n      defineProperty(object, name, nonEnumerableDataDescriptor);\\n    }\\n    getOwnPropertyNames(window);\\n    function getWrapperConstructor(node, opt_instance) {\\n      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\\n      if (isFirefox) {\\n        try {\\n          getOwnPropertyNames(nativePrototype);\\n        } catch (error) {\\n          nativePrototype = nativePrototype.__proto__;\\n        }\\n      }\\n      var wrapperConstructor = constructorTable.get(nativePrototype);\\n      if (wrapperConstructor) return wrapperConstructor;\\n      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\\n      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\\n      registerInternal(nativePrototype, GeneratedWrapper, opt_instance);\\n      return GeneratedWrapper;\\n    }\\n    function addForwardingProperties(nativePrototype, wrapperPrototype) {\\n      installProperty(nativePrototype, wrapperPrototype, true);\\n    }\\n    function registerInstanceProperties(wrapperPrototype, instanceObject) {\\n      installProperty(instanceObject, wrapperPrototype, false);\\n    }\\n    var isFirefox = /Firefox/.test(navigator.userAgent);\\n    var dummyDescriptor = {\\n      get: function() {},\\n      set: function(v) {},\\n      configurable: true,\\n      enumerable: true\\n    };\\n    function isEventHandlerName(name) {\\n      return /^on[a-z]+$/.test(name);\\n    }\\n    function isIdentifierName(name) {\\n      return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);\\n    }\\n    function getGetter(name) {\\n      return hasEval && isIdentifierName(name) ? new Function(\\\"return this.__impl4cf1e782hg__.\\\" + name) : function() {\\n        return this.__impl4cf1e782hg__[name];\\n      };\\n    }\\n    function getSetter(name) {\\n      return hasEval && isIdentifierName(name) ? new Function(\\\"v\\\", \\\"this.__impl4cf1e782hg__.\\\" + name + \\\" = v\\\") : function(v) {\\n        this.__impl4cf1e782hg__[name] = v;\\n      };\\n    }\\n    function getMethod(name) {\\n      return hasEval && isIdentifierName(name) ? new Function(\\\"return this.__impl4cf1e782hg__.\\\" + name + \\\".apply(this.__impl4cf1e782hg__, arguments)\\\") : function() {\\n        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);\\n      };\\n    }\\n    function getDescriptor(source, name) {\\n      try {\\n        if (source === window && name === \\\"showModalDialog\\\") {\\n          return dummyDescriptor;\\n        }\\n        return Object.getOwnPropertyDescriptor(source, name);\\n      } catch (ex) {\\n        return dummyDescriptor;\\n      }\\n    }\\n    var isBrokenSafari = function() {\\n      var descr = Object.getOwnPropertyDescriptor(Node.prototype, \\\"nodeType\\\");\\n      return descr && !descr.get && !descr.set;\\n    }();\\n    function installProperty(source, target, allowMethod, opt_blacklist) {\\n      var names = getOwnPropertyNames(source);\\n      for (var i = 0; i < names.length; i++) {\\n        var name = names[i];\\n        if (name === \\\"polymerBlackList_\\\") continue;\\n        if (name in target) continue;\\n        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;\\n        if (isFirefox) {\\n          source.__lookupGetter__(name);\\n        }\\n        var descriptor = getDescriptor(source, name);\\n        var getter, setter;\\n        if (typeof descriptor.value === \\\"function\\\") {\\n          if (allowMethod) {\\n            target[name] = getMethod(name);\\n          }\\n          continue;\\n        }\\n        var isEvent = isEventHandlerName(name);\\n        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);\\n        if (descriptor.writable || descriptor.set || isBrokenSafari) {\\n          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);\\n        }\\n        var configurable = isBrokenSafari || descriptor.configurable;\\n        defineProperty(target, name, {\\n          get: getter,\\n          set: setter,\\n          configurable: configurable,\\n          enumerable: descriptor.enumerable\\n        });\\n      }\\n    }\\n    function register(nativeConstructor, wrapperConstructor, opt_instance) {\\n      if (nativeConstructor == null) {\\n        return;\\n      }\\n      var nativePrototype = nativeConstructor.prototype;\\n      registerInternal(nativePrototype, wrapperConstructor, opt_instance);\\n      mixinStatics(wrapperConstructor, nativeConstructor);\\n    }\\n    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\\n      var wrapperPrototype = wrapperConstructor.prototype;\\n      assert(constructorTable.get(nativePrototype) === undefined);\\n      constructorTable.set(nativePrototype, wrapperConstructor);\\n      nativePrototypeTable.set(wrapperPrototype, nativePrototype);\\n      addForwardingProperties(nativePrototype, wrapperPrototype);\\n      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);\\n      defineNonEnumerableDataProperty(wrapperPrototype, \\\"constructor\\\", wrapperConstructor);\\n      wrapperConstructor.prototype = wrapperPrototype;\\n    }\\n    function isWrapperFor(wrapperConstructor, nativeConstructor) {\\n      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;\\n    }\\n    function registerObject(object) {\\n      var nativePrototype = Object.getPrototypeOf(object);\\n      var superWrapperConstructor = getWrapperConstructor(nativePrototype);\\n      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\\n      registerInternal(nativePrototype, GeneratedWrapper, object);\\n      return GeneratedWrapper;\\n    }\\n    function createWrapperConstructor(superWrapperConstructor) {\\n      function GeneratedWrapper(node) {\\n        superWrapperConstructor.call(this, node);\\n      }\\n      var p = Object.create(superWrapperConstructor.prototype);\\n      p.constructor = GeneratedWrapper;\\n      GeneratedWrapper.prototype = p;\\n      return GeneratedWrapper;\\n    }\\n    function isWrapper(object) {\\n      return object && object.__impl4cf1e782hg__;\\n    }\\n    function isNative(object) {\\n      return !isWrapper(object);\\n    }\\n    function wrap(impl) {\\n      if (impl === null) return null;\\n      assert(isNative(impl));\\n      var wrapper = impl.__wrapper8e3dd93a60__;\\n      if (wrapper != null) {\\n        return wrapper;\\n      }\\n      return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);\\n    }\\n    function unwrap(wrapper) {\\n      if (wrapper === null) return null;\\n      assert(isWrapper(wrapper));\\n      return wrapper.__impl4cf1e782hg__;\\n    }\\n    function unsafeUnwrap(wrapper) {\\n      return wrapper.__impl4cf1e782hg__;\\n    }\\n    function setWrapper(impl, wrapper) {\\n      wrapper.__impl4cf1e782hg__ = impl;\\n      impl.__wrapper8e3dd93a60__ = wrapper;\\n    }\\n    function unwrapIfNeeded(object) {\\n      return object && isWrapper(object) ? unwrap(object) : object;\\n    }\\n    function wrapIfNeeded(object) {\\n      return object && !isWrapper(object) ? wrap(object) : object;\\n    }\\n    function rewrap(node, wrapper) {\\n      if (wrapper === null) return;\\n      assert(isNative(node));\\n      assert(wrapper === undefined || isWrapper(wrapper));\\n      node.__wrapper8e3dd93a60__ = wrapper;\\n    }\\n    var getterDescriptor = {\\n      get: undefined,\\n      configurable: true,\\n      enumerable: true\\n    };\\n    function defineGetter(constructor, name, getter) {\\n      getterDescriptor.get = getter;\\n      defineProperty(constructor.prototype, name, getterDescriptor);\\n    }\\n    function defineWrapGetter(constructor, name) {\\n      defineGetter(constructor, name, function() {\\n        return wrap(this.__impl4cf1e782hg__[name]);\\n      });\\n    }\\n    function forwardMethodsToWrapper(constructors, names) {\\n      constructors.forEach(function(constructor) {\\n        names.forEach(function(name) {\\n          constructor.prototype[name] = function() {\\n            var w = wrapIfNeeded(this);\\n            return w[name].apply(w, arguments);\\n          };\\n        });\\n      });\\n    }\\n    scope.addForwardingProperties = addForwardingProperties;\\n    scope.assert = assert;\\n    scope.constructorTable = constructorTable;\\n    scope.defineGetter = defineGetter;\\n    scope.defineWrapGetter = defineWrapGetter;\\n    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\\n    scope.isIdentifierName = isIdentifierName;\\n    scope.isWrapper = isWrapper;\\n    scope.isWrapperFor = isWrapperFor;\\n    scope.mixin = mixin;\\n    scope.nativePrototypeTable = nativePrototypeTable;\\n    scope.oneOf = oneOf;\\n    scope.registerObject = registerObject;\\n    scope.registerWrapper = register;\\n    scope.rewrap = rewrap;\\n    scope.setWrapper = setWrapper;\\n    scope.unsafeUnwrap = unsafeUnwrap;\\n    scope.unwrap = unwrap;\\n    scope.unwrapIfNeeded = unwrapIfNeeded;\\n    scope.wrap = wrap;\\n    scope.wrapIfNeeded = wrapIfNeeded;\\n    scope.wrappers = wrappers;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    function newSplice(index, removed, addedCount) {\\n      return {\\n        index: index,\\n        removed: removed,\\n        addedCount: addedCount\\n      };\\n    }\\n    var EDIT_LEAVE = 0;\\n    var EDIT_UPDATE = 1;\\n    var EDIT_ADD = 2;\\n    var EDIT_DELETE = 3;\\n    function ArraySplice() {}\\n    ArraySplice.prototype = {\\n      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\\n        var rowCount = oldEnd - oldStart + 1;\\n        var columnCount = currentEnd - currentStart + 1;\\n        var distances = new Array(rowCount);\\n        for (var i = 0; i < rowCount; i++) {\\n          distances[i] = new Array(columnCount);\\n          distances[i][0] = i;\\n        }\\n        for (var j = 0; j < columnCount; j++) distances[0][j] = j;\\n        for (var i = 1; i < rowCount; i++) {\\n          for (var j = 1; j < columnCount; j++) {\\n            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {\\n              var north = distances[i - 1][j] + 1;\\n              var west = distances[i][j - 1] + 1;\\n              distances[i][j] = north < west ? north : west;\\n            }\\n          }\\n        }\\n        return distances;\\n      },\\n      spliceOperationsFromEditDistances: function(distances) {\\n        var i = distances.length - 1;\\n        var j = distances[0].length - 1;\\n        var current = distances[i][j];\\n        var edits = [];\\n        while (i > 0 || j > 0) {\\n          if (i == 0) {\\n            edits.push(EDIT_ADD);\\n            j--;\\n            continue;\\n          }\\n          if (j == 0) {\\n            edits.push(EDIT_DELETE);\\n            i--;\\n            continue;\\n          }\\n          var northWest = distances[i - 1][j - 1];\\n          var west = distances[i - 1][j];\\n          var north = distances[i][j - 1];\\n          var min;\\n          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;\\n          if (min == northWest) {\\n            if (northWest == current) {\\n              edits.push(EDIT_LEAVE);\\n            } else {\\n              edits.push(EDIT_UPDATE);\\n              current = northWest;\\n            }\\n            i--;\\n            j--;\\n          } else if (min == west) {\\n            edits.push(EDIT_DELETE);\\n            i--;\\n            current = west;\\n          } else {\\n            edits.push(EDIT_ADD);\\n            j--;\\n            current = north;\\n          }\\n        }\\n        edits.reverse();\\n        return edits;\\n      },\\n      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\\n        var prefixCount = 0;\\n        var suffixCount = 0;\\n        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\\n        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);\\n        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\\n        currentStart += prefixCount;\\n        oldStart += prefixCount;\\n        currentEnd -= suffixCount;\\n        oldEnd -= suffixCount;\\n        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\\n        if (currentStart == currentEnd) {\\n          var splice = newSplice(currentStart, [], 0);\\n          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\\n          return [ splice ];\\n        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];\\n        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\\n        var splice = undefined;\\n        var splices = [];\\n        var index = currentStart;\\n        var oldIndex = oldStart;\\n        for (var i = 0; i < ops.length; i++) {\\n          switch (ops[i]) {\\n           case EDIT_LEAVE:\\n            if (splice) {\\n              splices.push(splice);\\n              splice = undefined;\\n            }\\n            index++;\\n            oldIndex++;\\n            break;\\n\\n           case EDIT_UPDATE:\\n            if (!splice) splice = newSplice(index, [], 0);\\n            splice.addedCount++;\\n            index++;\\n            splice.removed.push(old[oldIndex]);\\n            oldIndex++;\\n            break;\\n\\n           case EDIT_ADD:\\n            if (!splice) splice = newSplice(index, [], 0);\\n            splice.addedCount++;\\n            index++;\\n            break;\\n\\n           case EDIT_DELETE:\\n            if (!splice) splice = newSplice(index, [], 0);\\n            splice.removed.push(old[oldIndex]);\\n            oldIndex++;\\n            break;\\n          }\\n        }\\n        if (splice) {\\n          splices.push(splice);\\n        }\\n        return splices;\\n      },\\n      sharedPrefix: function(current, old, searchLength) {\\n        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;\\n        return searchLength;\\n      },\\n      sharedSuffix: function(current, old, searchLength) {\\n        var index1 = current.length;\\n        var index2 = old.length;\\n        var count = 0;\\n        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;\\n        return count;\\n      },\\n      calculateSplices: function(current, previous) {\\n        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);\\n      },\\n      equals: function(currentValue, previousValue) {\\n        return currentValue === previousValue;\\n      }\\n    };\\n    scope.ArraySplice = ArraySplice;\\n  })(window.ShadowDOMPolyfill);\\n  (function(context) {\\n    \\\"use strict\\\";\\n    var OriginalMutationObserver = window.MutationObserver;\\n    var callbacks = [];\\n    var pending = false;\\n    var timerFunc;\\n    function handle() {\\n      pending = false;\\n      var copies = callbacks.slice(0);\\n      callbacks = [];\\n      for (var i = 0; i < copies.length; i++) {\\n        (0, copies[i])();\\n      }\\n    }\\n    if (OriginalMutationObserver) {\\n      var counter = 1;\\n      var observer = new OriginalMutationObserver(handle);\\n      var textNode = document.createTextNode(counter);\\n      observer.observe(textNode, {\\n        characterData: true\\n      });\\n      timerFunc = function() {\\n        counter = (counter + 1) % 2;\\n        textNode.data = counter;\\n      };\\n    } else {\\n      timerFunc = window.setTimeout;\\n    }\\n    function setEndOfMicrotask(func) {\\n      callbacks.push(func);\\n      if (pending) return;\\n      pending = true;\\n      timerFunc(handle, 0);\\n    }\\n    context.setEndOfMicrotask = setEndOfMicrotask;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var setEndOfMicrotask = scope.setEndOfMicrotask;\\n    var wrapIfNeeded = scope.wrapIfNeeded;\\n    var wrappers = scope.wrappers;\\n    var registrationsTable = new WeakMap();\\n    var globalMutationObservers = [];\\n    var isScheduled = false;\\n    function scheduleCallback(observer) {\\n      if (observer.scheduled_) return;\\n      observer.scheduled_ = true;\\n      globalMutationObservers.push(observer);\\n      if (isScheduled) return;\\n      setEndOfMicrotask(notifyObservers);\\n      isScheduled = true;\\n    }\\n    function notifyObservers() {\\n      isScheduled = false;\\n      while (globalMutationObservers.length) {\\n        var notifyList = globalMutationObservers;\\n        globalMutationObservers = [];\\n        notifyList.sort(function(x, y) {\\n          return x.uid_ - y.uid_;\\n        });\\n        for (var i = 0; i < notifyList.length; i++) {\\n          var mo = notifyList[i];\\n          mo.scheduled_ = false;\\n          var queue = mo.takeRecords();\\n          removeTransientObserversFor(mo);\\n          if (queue.length) {\\n            mo.callback_(queue, mo);\\n          }\\n        }\\n      }\\n    }\\n    function MutationRecord(type, target) {\\n      this.type = type;\\n      this.target = target;\\n      this.addedNodes = new wrappers.NodeList();\\n      this.removedNodes = new wrappers.NodeList();\\n      this.previousSibling = null;\\n      this.nextSibling = null;\\n      this.attributeName = null;\\n      this.attributeNamespace = null;\\n      this.oldValue = null;\\n    }\\n    function registerTransientObservers(ancestor, node) {\\n      for (;ancestor; ancestor = ancestor.parentNode) {\\n        var registrations = registrationsTable.get(ancestor);\\n        if (!registrations) continue;\\n        for (var i = 0; i < registrations.length; i++) {\\n          var registration = registrations[i];\\n          if (registration.options.subtree) registration.addTransientObserver(node);\\n        }\\n      }\\n    }\\n    function removeTransientObserversFor(observer) {\\n      for (var i = 0; i < observer.nodes_.length; i++) {\\n        var node = observer.nodes_[i];\\n        var registrations = registrationsTable.get(node);\\n        if (!registrations) return;\\n        for (var j = 0; j < registrations.length; j++) {\\n          var registration = registrations[j];\\n          if (registration.observer === observer) registration.removeTransientObservers();\\n        }\\n      }\\n    }\\n    function enqueueMutation(target, type, data) {\\n      var interestedObservers = Object.create(null);\\n      var associatedStrings = Object.create(null);\\n      for (var node = target; node; node = node.parentNode) {\\n        var registrations = registrationsTable.get(node);\\n        if (!registrations) continue;\\n        for (var j = 0; j < registrations.length; j++) {\\n          var registration = registrations[j];\\n          var options = registration.options;\\n          if (node !== target && !options.subtree) continue;\\n          if (type === \\\"attributes\\\" && !options.attributes) continue;\\n          if (type === \\\"attributes\\\" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {\\n            continue;\\n          }\\n          if (type === \\\"characterData\\\" && !options.characterData) continue;\\n          if (type === \\\"childList\\\" && !options.childList) continue;\\n          var observer = registration.observer;\\n          interestedObservers[observer.uid_] = observer;\\n          if (type === \\\"attributes\\\" && options.attributeOldValue || type === \\\"characterData\\\" && options.characterDataOldValue) {\\n            associatedStrings[observer.uid_] = data.oldValue;\\n          }\\n        }\\n      }\\n      for (var uid in interestedObservers) {\\n        var observer = interestedObservers[uid];\\n        var record = new MutationRecord(type, target);\\n        if (\\\"name\\\" in data && \\\"namespace\\\" in data) {\\n          record.attributeName = data.name;\\n          record.attributeNamespace = data.namespace;\\n        }\\n        if (data.addedNodes) record.addedNodes = data.addedNodes;\\n        if (data.removedNodes) record.removedNodes = data.removedNodes;\\n        if (data.previousSibling) record.previousSibling = data.previousSibling;\\n        if (data.nextSibling) record.nextSibling = data.nextSibling;\\n        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];\\n        scheduleCallback(observer);\\n        observer.records_.push(record);\\n      }\\n    }\\n    var slice = Array.prototype.slice;\\n    function MutationObserverOptions(options) {\\n      this.childList = !!options.childList;\\n      this.subtree = !!options.subtree;\\n      if (!(\\\"attributes\\\" in options) && (\\\"attributeOldValue\\\" in options || \\\"attributeFilter\\\" in options)) {\\n        this.attributes = true;\\n      } else {\\n        this.attributes = !!options.attributes;\\n      }\\n      if (\\\"characterDataOldValue\\\" in options && !(\\\"characterData\\\" in options)) this.characterData = true; else this.characterData = !!options.characterData;\\n      if (!this.attributes && (options.attributeOldValue || \\\"attributeFilter\\\" in options) || !this.characterData && options.characterDataOldValue) {\\n        throw new TypeError();\\n      }\\n      this.characterData = !!options.characterData;\\n      this.attributeOldValue = !!options.attributeOldValue;\\n      this.characterDataOldValue = !!options.characterDataOldValue;\\n      if (\\\"attributeFilter\\\" in options) {\\n        if (options.attributeFilter == null || typeof options.attributeFilter !== \\\"object\\\") {\\n          throw new TypeError();\\n        }\\n        this.attributeFilter = slice.call(options.attributeFilter);\\n      } else {\\n        this.attributeFilter = null;\\n      }\\n    }\\n    var uidCounter = 0;\\n    function MutationObserver(callback) {\\n      this.callback_ = callback;\\n      this.nodes_ = [];\\n      this.records_ = [];\\n      this.uid_ = ++uidCounter;\\n      this.scheduled_ = false;\\n    }\\n    MutationObserver.prototype = {\\n      constructor: MutationObserver,\\n      observe: function(target, options) {\\n        target = wrapIfNeeded(target);\\n        var newOptions = new MutationObserverOptions(options);\\n        var registration;\\n        var registrations = registrationsTable.get(target);\\n        if (!registrations) registrationsTable.set(target, registrations = []);\\n        for (var i = 0; i < registrations.length; i++) {\\n          if (registrations[i].observer === this) {\\n            registration = registrations[i];\\n            registration.removeTransientObservers();\\n            registration.options = newOptions;\\n          }\\n        }\\n        if (!registration) {\\n          registration = new Registration(this, target, newOptions);\\n          registrations.push(registration);\\n          this.nodes_.push(target);\\n        }\\n      },\\n      disconnect: function() {\\n        this.nodes_.forEach(function(node) {\\n          var registrations = registrationsTable.get(node);\\n          for (var i = 0; i < registrations.length; i++) {\\n            var registration = registrations[i];\\n            if (registration.observer === this) {\\n              registrations.splice(i, 1);\\n              break;\\n            }\\n          }\\n        }, this);\\n        this.records_ = [];\\n      },\\n      takeRecords: function() {\\n        var copyOfRecords = this.records_;\\n        this.records_ = [];\\n        return copyOfRecords;\\n      }\\n    };\\n    function Registration(observer, target, options) {\\n      this.observer = observer;\\n      this.target = target;\\n      this.options = options;\\n      this.transientObservedNodes = [];\\n    }\\n    Registration.prototype = {\\n      addTransientObserver: function(node) {\\n        if (node === this.target) return;\\n        scheduleCallback(this.observer);\\n        this.transientObservedNodes.push(node);\\n        var registrations = registrationsTable.get(node);\\n        if (!registrations) registrationsTable.set(node, registrations = []);\\n        registrations.push(this);\\n      },\\n      removeTransientObservers: function() {\\n        var transientObservedNodes = this.transientObservedNodes;\\n        this.transientObservedNodes = [];\\n        for (var i = 0; i < transientObservedNodes.length; i++) {\\n          var node = transientObservedNodes[i];\\n          var registrations = registrationsTable.get(node);\\n          for (var j = 0; j < registrations.length; j++) {\\n            if (registrations[j] === this) {\\n              registrations.splice(j, 1);\\n              break;\\n            }\\n          }\\n        }\\n      }\\n    };\\n    scope.enqueueMutation = enqueueMutation;\\n    scope.registerTransientObservers = registerTransientObservers;\\n    scope.wrappers.MutationObserver = MutationObserver;\\n    scope.wrappers.MutationRecord = MutationRecord;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    function TreeScope(root, parent) {\\n      this.root = root;\\n      this.parent = parent;\\n    }\\n    TreeScope.prototype = {\\n      get renderer() {\\n        if (this.root instanceof scope.wrappers.ShadowRoot) {\\n          return scope.getRendererForHost(this.root.host);\\n        }\\n        return null;\\n      },\\n      contains: function(treeScope) {\\n        for (;treeScope; treeScope = treeScope.parent) {\\n          if (treeScope === this) return true;\\n        }\\n        return false;\\n      }\\n    };\\n    function setTreeScope(node, treeScope) {\\n      if (node.treeScope_ !== treeScope) {\\n        node.treeScope_ = treeScope;\\n        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\\n          sr.treeScope_.parent = treeScope;\\n        }\\n        for (var child = node.firstChild; child; child = child.nextSibling) {\\n          setTreeScope(child, treeScope);\\n        }\\n      }\\n    }\\n    function getTreeScope(node) {\\n      if (node instanceof scope.wrappers.Window) {\\n        debugger;\\n      }\\n      if (node.treeScope_) return node.treeScope_;\\n      var parent = node.parentNode;\\n      var treeScope;\\n      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);\\n      return node.treeScope_ = treeScope;\\n    }\\n    scope.TreeScope = TreeScope;\\n    scope.getTreeScope = getTreeScope;\\n    scope.setTreeScope = setTreeScope;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\\n    var getTreeScope = scope.getTreeScope;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var wrappers = scope.wrappers;\\n    var wrappedFuns = new WeakMap();\\n    var listenersTable = new WeakMap();\\n    var handledEventsTable = new WeakMap();\\n    var currentlyDispatchingEvents = new WeakMap();\\n    var targetTable = new WeakMap();\\n    var currentTargetTable = new WeakMap();\\n    var relatedTargetTable = new WeakMap();\\n    var eventPhaseTable = new WeakMap();\\n    var stopPropagationTable = new WeakMap();\\n    var stopImmediatePropagationTable = new WeakMap();\\n    var eventHandlersTable = new WeakMap();\\n    var eventPathTable = new WeakMap();\\n    function isShadowRoot(node) {\\n      return node instanceof wrappers.ShadowRoot;\\n    }\\n    function rootOfNode(node) {\\n      return getTreeScope(node).root;\\n    }\\n    function getEventPath(node, event) {\\n      var path = [];\\n      var current = node;\\n      path.push(current);\\n      while (current) {\\n        var destinationInsertionPoints = getDestinationInsertionPoints(current);\\n        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\\n          for (var i = 0; i < destinationInsertionPoints.length; i++) {\\n            var insertionPoint = destinationInsertionPoints[i];\\n            if (isShadowInsertionPoint(insertionPoint)) {\\n              var shadowRoot = rootOfNode(insertionPoint);\\n              var olderShadowRoot = shadowRoot.olderShadowRoot;\\n              if (olderShadowRoot) path.push(olderShadowRoot);\\n            }\\n            path.push(insertionPoint);\\n          }\\n          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];\\n        } else {\\n          if (isShadowRoot(current)) {\\n            if (inSameTree(node, current) && eventMustBeStopped(event)) {\\n              break;\\n            }\\n            current = current.host;\\n            path.push(current);\\n          } else {\\n            current = current.parentNode;\\n            if (current) path.push(current);\\n          }\\n        }\\n      }\\n      return path;\\n    }\\n    function eventMustBeStopped(event) {\\n      if (!event) return false;\\n      switch (event.type) {\\n       case \\\"abort\\\":\\n       case \\\"error\\\":\\n       case \\\"select\\\":\\n       case \\\"change\\\":\\n       case \\\"load\\\":\\n       case \\\"reset\\\":\\n       case \\\"resize\\\":\\n       case \\\"scroll\\\":\\n       case \\\"selectstart\\\":\\n        return true;\\n      }\\n      return false;\\n    }\\n    function isShadowInsertionPoint(node) {\\n      return node instanceof HTMLShadowElement;\\n    }\\n    function getDestinationInsertionPoints(node) {\\n      return scope.getDestinationInsertionPoints(node);\\n    }\\n    function eventRetargetting(path, currentTarget) {\\n      if (path.length === 0) return currentTarget;\\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\\n      var currentTargetTree = getTreeScope(currentTarget);\\n      var originalTarget = path[0];\\n      var originalTargetTree = getTreeScope(originalTarget);\\n      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\\n      for (var i = 0; i < path.length; i++) {\\n        var node = path[i];\\n        if (getTreeScope(node) === relativeTargetTree) return node;\\n      }\\n      return path[path.length - 1];\\n    }\\n    function getTreeScopeAncestors(treeScope) {\\n      var ancestors = [];\\n      for (;treeScope; treeScope = treeScope.parent) {\\n        ancestors.push(treeScope);\\n      }\\n      return ancestors;\\n    }\\n    function lowestCommonInclusiveAncestor(tsA, tsB) {\\n      var ancestorsA = getTreeScopeAncestors(tsA);\\n      var ancestorsB = getTreeScopeAncestors(tsB);\\n      var result = null;\\n      while (ancestorsA.length > 0 && ancestorsB.length > 0) {\\n        var a = ancestorsA.pop();\\n        var b = ancestorsB.pop();\\n        if (a === b) result = a; else break;\\n      }\\n      return result;\\n    }\\n    function getTreeScopeRoot(ts) {\\n      if (!ts.parent) return ts;\\n      return getTreeScopeRoot(ts.parent);\\n    }\\n    function relatedTargetResolution(event, currentTarget, relatedTarget) {\\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\\n      var currentTargetTree = getTreeScope(currentTarget);\\n      var relatedTargetTree = getTreeScope(relatedTarget);\\n      var relatedTargetEventPath = getEventPath(relatedTarget, event);\\n      var lowestCommonAncestorTree;\\n      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\\n      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;\\n      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {\\n        var adjustedRelatedTarget;\\n        for (var i = 0; i < relatedTargetEventPath.length; i++) {\\n          var node = relatedTargetEventPath[i];\\n          if (getTreeScope(node) === commonAncestorTree) return node;\\n        }\\n      }\\n      return null;\\n    }\\n    function inSameTree(a, b) {\\n      return getTreeScope(a) === getTreeScope(b);\\n    }\\n    var NONE = 0;\\n    var CAPTURING_PHASE = 1;\\n    var AT_TARGET = 2;\\n    var BUBBLING_PHASE = 3;\\n    var pendingError;\\n    function dispatchOriginalEvent(originalEvent) {\\n      if (handledEventsTable.get(originalEvent)) return;\\n      handledEventsTable.set(originalEvent, true);\\n      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\\n      if (pendingError) {\\n        var err = pendingError;\\n        pendingError = null;\\n        throw err;\\n      }\\n    }\\n    function isLoadLikeEvent(event) {\\n      switch (event.type) {\\n       case \\\"load\\\":\\n       case \\\"beforeunload\\\":\\n       case \\\"unload\\\":\\n        return true;\\n      }\\n      return false;\\n    }\\n    function dispatchEvent(event, originalWrapperTarget) {\\n      if (currentlyDispatchingEvents.get(event)) throw new Error(\\\"InvalidStateError\\\");\\n      currentlyDispatchingEvents.set(event, true);\\n      scope.renderAllPending();\\n      var eventPath;\\n      var overrideTarget;\\n      var win;\\n      if (isLoadLikeEvent(event) && !event.bubbles) {\\n        var doc = originalWrapperTarget;\\n        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\\n          overrideTarget = doc;\\n          eventPath = [];\\n        }\\n      }\\n      if (!eventPath) {\\n        if (originalWrapperTarget instanceof wrappers.Window) {\\n          win = originalWrapperTarget;\\n          eventPath = [];\\n        } else {\\n          eventPath = getEventPath(originalWrapperTarget, event);\\n          if (!isLoadLikeEvent(event)) {\\n            var doc = eventPath[eventPath.length - 1];\\n            if (doc instanceof wrappers.Document) win = doc.defaultView;\\n          }\\n        }\\n      }\\n      eventPathTable.set(event, eventPath);\\n      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\\n        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\\n          dispatchBubbling(event, eventPath, win, overrideTarget);\\n        }\\n      }\\n      eventPhaseTable.set(event, NONE);\\n      currentTargetTable.delete(event, null);\\n      currentlyDispatchingEvents.delete(event);\\n      return event.defaultPrevented;\\n    }\\n    function dispatchCapturing(event, eventPath, win, overrideTarget) {\\n      var phase = CAPTURING_PHASE;\\n      if (win) {\\n        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;\\n      }\\n      for (var i = eventPath.length - 1; i > 0; i--) {\\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;\\n      }\\n      return true;\\n    }\\n    function dispatchAtTarget(event, eventPath, win, overrideTarget) {\\n      var phase = AT_TARGET;\\n      var currentTarget = eventPath[0] || win;\\n      return invoke(currentTarget, event, phase, eventPath, overrideTarget);\\n    }\\n    function dispatchBubbling(event, eventPath, win, overrideTarget) {\\n      var phase = BUBBLING_PHASE;\\n      for (var i = 1; i < eventPath.length; i++) {\\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;\\n      }\\n      if (win && eventPath.length > 0) {\\n        invoke(win, event, phase, eventPath, overrideTarget);\\n      }\\n    }\\n    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\\n      var listeners = listenersTable.get(currentTarget);\\n      if (!listeners) return true;\\n      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\\n      if (target === currentTarget) {\\n        if (phase === CAPTURING_PHASE) return true;\\n        if (phase === BUBBLING_PHASE) phase = AT_TARGET;\\n      } else if (phase === BUBBLING_PHASE && !event.bubbles) {\\n        return true;\\n      }\\n      if (\\\"relatedTarget\\\" in event) {\\n        var originalEvent = unwrap(event);\\n        var unwrappedRelatedTarget = originalEvent.relatedTarget;\\n        if (unwrappedRelatedTarget) {\\n          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {\\n            var relatedTarget = wrap(unwrappedRelatedTarget);\\n            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);\\n            if (adjusted === target) return true;\\n          } else {\\n            adjusted = null;\\n          }\\n          relatedTargetTable.set(event, adjusted);\\n        }\\n      }\\n      eventPhaseTable.set(event, phase);\\n      var type = event.type;\\n      var anyRemoved = false;\\n      targetTable.set(event, target);\\n      currentTargetTable.set(event, currentTarget);\\n      listeners.depth++;\\n      for (var i = 0, len = listeners.length; i < len; i++) {\\n        var listener = listeners[i];\\n        if (listener.removed) {\\n          anyRemoved = true;\\n          continue;\\n        }\\n        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {\\n          continue;\\n        }\\n        try {\\n          if (typeof listener.handler === \\\"function\\\") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);\\n          if (stopImmediatePropagationTable.get(event)) return false;\\n        } catch (ex) {\\n          if (!pendingError) pendingError = ex;\\n        }\\n      }\\n      listeners.depth--;\\n      if (anyRemoved && listeners.depth === 0) {\\n        var copy = listeners.slice();\\n        listeners.length = 0;\\n        for (var i = 0; i < copy.length; i++) {\\n          if (!copy[i].removed) listeners.push(copy[i]);\\n        }\\n      }\\n      return !stopPropagationTable.get(event);\\n    }\\n    function Listener(type, handler, capture) {\\n      this.type = type;\\n      this.handler = handler;\\n      this.capture = Boolean(capture);\\n    }\\n    Listener.prototype = {\\n      equals: function(that) {\\n        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;\\n      },\\n      get removed() {\\n        return this.handler === null;\\n      },\\n      remove: function() {\\n        this.handler = null;\\n      }\\n    };\\n    var OriginalEvent = window.Event;\\n    OriginalEvent.prototype.polymerBlackList_ = {\\n      returnValue: true,\\n      keyLocation: true\\n    };\\n    function Event(type, options) {\\n      if (type instanceof OriginalEvent) {\\n        var impl = type;\\n        if (!OriginalBeforeUnloadEvent && impl.type === \\\"beforeunload\\\" && !(this instanceof BeforeUnloadEvent)) {\\n          return new BeforeUnloadEvent(impl);\\n        }\\n        setWrapper(impl, this);\\n      } else {\\n        return wrap(constructEvent(OriginalEvent, \\\"Event\\\", type, options));\\n      }\\n    }\\n    Event.prototype = {\\n      get target() {\\n        return targetTable.get(this);\\n      },\\n      get currentTarget() {\\n        return currentTargetTable.get(this);\\n      },\\n      get eventPhase() {\\n        return eventPhaseTable.get(this);\\n      },\\n      get path() {\\n        var eventPath = eventPathTable.get(this);\\n        if (!eventPath) return [];\\n        return eventPath.slice();\\n      },\\n      stopPropagation: function() {\\n        stopPropagationTable.set(this, true);\\n      },\\n      stopImmediatePropagation: function() {\\n        stopPropagationTable.set(this, true);\\n        stopImmediatePropagationTable.set(this, true);\\n      }\\n    };\\n    var supportsDefaultPrevented = function() {\\n      var e = document.createEvent(\\\"Event\\\");\\n      e.initEvent(\\\"test\\\", true, true);\\n      e.preventDefault();\\n      return e.defaultPrevented;\\n    }();\\n    if (!supportsDefaultPrevented) {\\n      Event.prototype.preventDefault = function() {\\n        if (!this.cancelable) return;\\n        unsafeUnwrap(this).preventDefault();\\n        Object.defineProperty(this, \\\"defaultPrevented\\\", {\\n          get: function() {\\n            return true;\\n          },\\n          configurable: true\\n        });\\n      };\\n    }\\n    registerWrapper(OriginalEvent, Event, document.createEvent(\\\"Event\\\"));\\n    function unwrapOptions(options) {\\n      if (!options || !options.relatedTarget) return options;\\n      return Object.create(options, {\\n        relatedTarget: {\\n          value: unwrap(options.relatedTarget)\\n        }\\n      });\\n    }\\n    function registerGenericEvent(name, SuperEvent, prototype) {\\n      var OriginalEvent = window[name];\\n      var GenericEvent = function(type, options) {\\n        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));\\n      };\\n      GenericEvent.prototype = Object.create(SuperEvent.prototype);\\n      if (prototype) mixin(GenericEvent.prototype, prototype);\\n      if (OriginalEvent) {\\n        try {\\n          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent(\\\"temp\\\"));\\n        } catch (ex) {\\n          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));\\n        }\\n      }\\n      return GenericEvent;\\n    }\\n    var UIEvent = registerGenericEvent(\\\"UIEvent\\\", Event);\\n    var CustomEvent = registerGenericEvent(\\\"CustomEvent\\\", Event);\\n    var relatedTargetProto = {\\n      get relatedTarget() {\\n        var relatedTarget = relatedTargetTable.get(this);\\n        if (relatedTarget !== undefined) return relatedTarget;\\n        return wrap(unwrap(this).relatedTarget);\\n      }\\n    };\\n    function getInitFunction(name, relatedTargetIndex) {\\n      return function() {\\n        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\\n        var impl = unwrap(this);\\n        impl[name].apply(impl, arguments);\\n      };\\n    }\\n    var mouseEventProto = mixin({\\n      initMouseEvent: getInitFunction(\\\"initMouseEvent\\\", 14)\\n    }, relatedTargetProto);\\n    var focusEventProto = mixin({\\n      initFocusEvent: getInitFunction(\\\"initFocusEvent\\\", 5)\\n    }, relatedTargetProto);\\n    var MouseEvent = registerGenericEvent(\\\"MouseEvent\\\", UIEvent, mouseEventProto);\\n    var FocusEvent = registerGenericEvent(\\\"FocusEvent\\\", UIEvent, focusEventProto);\\n    var defaultInitDicts = Object.create(null);\\n    var supportsEventConstructors = function() {\\n      try {\\n        new window.FocusEvent(\\\"focus\\\");\\n      } catch (ex) {\\n        return false;\\n      }\\n      return true;\\n    }();\\n    function constructEvent(OriginalEvent, name, type, options) {\\n      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));\\n      var event = unwrap(document.createEvent(name));\\n      var defaultDict = defaultInitDicts[name];\\n      var args = [ type ];\\n      Object.keys(defaultDict).forEach(function(key) {\\n        var v = options != null && key in options ? options[key] : defaultDict[key];\\n        if (key === \\\"relatedTarget\\\") v = unwrap(v);\\n        args.push(v);\\n      });\\n      event[\\\"init\\\" + name].apply(event, args);\\n      return event;\\n    }\\n    if (!supportsEventConstructors) {\\n      var configureEventConstructor = function(name, initDict, superName) {\\n        if (superName) {\\n          var superDict = defaultInitDicts[superName];\\n          initDict = mixin(mixin({}, superDict), initDict);\\n        }\\n        defaultInitDicts[name] = initDict;\\n      };\\n      configureEventConstructor(\\\"Event\\\", {\\n        bubbles: false,\\n        cancelable: false\\n      });\\n      configureEventConstructor(\\\"CustomEvent\\\", {\\n        detail: null\\n      }, \\\"Event\\\");\\n      configureEventConstructor(\\\"UIEvent\\\", {\\n        view: null,\\n        detail: 0\\n      }, \\\"Event\\\");\\n      configureEventConstructor(\\\"MouseEvent\\\", {\\n        screenX: 0,\\n        screenY: 0,\\n        clientX: 0,\\n        clientY: 0,\\n        ctrlKey: false,\\n        altKey: false,\\n        shiftKey: false,\\n        metaKey: false,\\n        button: 0,\\n        relatedTarget: null\\n      }, \\\"UIEvent\\\");\\n      configureEventConstructor(\\\"FocusEvent\\\", {\\n        relatedTarget: null\\n      }, \\\"UIEvent\\\");\\n    }\\n    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\\n    function BeforeUnloadEvent(impl) {\\n      Event.call(this, impl);\\n    }\\n    BeforeUnloadEvent.prototype = Object.create(Event.prototype);\\n    mixin(BeforeUnloadEvent.prototype, {\\n      get returnValue() {\\n        return unsafeUnwrap(this).returnValue;\\n      },\\n      set returnValue(v) {\\n        unsafeUnwrap(this).returnValue = v;\\n      }\\n    });\\n    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\\n    function isValidListener(fun) {\\n      if (typeof fun === \\\"function\\\") return true;\\n      return fun && fun.handleEvent;\\n    }\\n    function isMutationEvent(type) {\\n      switch (type) {\\n       case \\\"DOMAttrModified\\\":\\n       case \\\"DOMAttributeNameChanged\\\":\\n       case \\\"DOMCharacterDataModified\\\":\\n       case \\\"DOMElementNameChanged\\\":\\n       case \\\"DOMNodeInserted\\\":\\n       case \\\"DOMNodeInsertedIntoDocument\\\":\\n       case \\\"DOMNodeRemoved\\\":\\n       case \\\"DOMNodeRemovedFromDocument\\\":\\n       case \\\"DOMSubtreeModified\\\":\\n        return true;\\n      }\\n      return false;\\n    }\\n    var OriginalEventTarget = window.EventTarget;\\n    function EventTarget(impl) {\\n      setWrapper(impl, this);\\n    }\\n    var methodNames = [ \\\"addEventListener\\\", \\\"removeEventListener\\\", \\\"dispatchEvent\\\" ];\\n    [ Node, Window ].forEach(function(constructor) {\\n      var p = constructor.prototype;\\n      methodNames.forEach(function(name) {\\n        Object.defineProperty(p, name + \\\"_\\\", {\\n          value: p[name]\\n        });\\n      });\\n    });\\n    function getTargetToListenAt(wrapper) {\\n      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;\\n      return unwrap(wrapper);\\n    }\\n    EventTarget.prototype = {\\n      addEventListener: function(type, fun, capture) {\\n        if (!isValidListener(fun) || isMutationEvent(type)) return;\\n        var listener = new Listener(type, fun, capture);\\n        var listeners = listenersTable.get(this);\\n        if (!listeners) {\\n          listeners = [];\\n          listeners.depth = 0;\\n          listenersTable.set(this, listeners);\\n        } else {\\n          for (var i = 0; i < listeners.length; i++) {\\n            if (listener.equals(listeners[i])) return;\\n          }\\n        }\\n        listeners.push(listener);\\n        var target = getTargetToListenAt(this);\\n        target.addEventListener_(type, dispatchOriginalEvent, true);\\n      },\\n      removeEventListener: function(type, fun, capture) {\\n        capture = Boolean(capture);\\n        var listeners = listenersTable.get(this);\\n        if (!listeners) return;\\n        var count = 0, found = false;\\n        for (var i = 0; i < listeners.length; i++) {\\n          if (listeners[i].type === type && listeners[i].capture === capture) {\\n            count++;\\n            if (listeners[i].handler === fun) {\\n              found = true;\\n              listeners[i].remove();\\n            }\\n          }\\n        }\\n        if (found && count === 1) {\\n          var target = getTargetToListenAt(this);\\n          target.removeEventListener_(type, dispatchOriginalEvent, true);\\n        }\\n      },\\n      dispatchEvent: function(event) {\\n        var nativeEvent = unwrap(event);\\n        var eventType = nativeEvent.type;\\n        handledEventsTable.set(nativeEvent, false);\\n        scope.renderAllPending();\\n        var tempListener;\\n        if (!hasListenerInAncestors(this, eventType)) {\\n          tempListener = function() {};\\n          this.addEventListener(eventType, tempListener, true);\\n        }\\n        try {\\n          return unwrap(this).dispatchEvent_(nativeEvent);\\n        } finally {\\n          if (tempListener) this.removeEventListener(eventType, tempListener, true);\\n        }\\n      }\\n    };\\n    function hasListener(node, type) {\\n      var listeners = listenersTable.get(node);\\n      if (listeners) {\\n        for (var i = 0; i < listeners.length; i++) {\\n          if (!listeners[i].removed && listeners[i].type === type) return true;\\n        }\\n      }\\n      return false;\\n    }\\n    function hasListenerInAncestors(target, type) {\\n      for (var node = unwrap(target); node; node = node.parentNode) {\\n        if (hasListener(wrap(node), type)) return true;\\n      }\\n      return false;\\n    }\\n    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);\\n    function wrapEventTargetMethods(constructors) {\\n      forwardMethodsToWrapper(constructors, methodNames);\\n    }\\n    var originalElementFromPoint = document.elementFromPoint;\\n    function elementFromPoint(self, document, x, y) {\\n      scope.renderAllPending();\\n      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\\n      if (!element) return null;\\n      var path = getEventPath(element, null);\\n      var idx = path.lastIndexOf(self);\\n      if (idx == -1) return null; else path = path.slice(0, idx);\\n      return eventRetargetting(path, self);\\n    }\\n    function getEventHandlerGetter(name) {\\n      return function() {\\n        var inlineEventHandlers = eventHandlersTable.get(this);\\n        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;\\n      };\\n    }\\n    function getEventHandlerSetter(name) {\\n      var eventType = name.slice(2);\\n      return function(value) {\\n        var inlineEventHandlers = eventHandlersTable.get(this);\\n        if (!inlineEventHandlers) {\\n          inlineEventHandlers = Object.create(null);\\n          eventHandlersTable.set(this, inlineEventHandlers);\\n        }\\n        var old = inlineEventHandlers[name];\\n        if (old) this.removeEventListener(eventType, old.wrapped, false);\\n        if (typeof value === \\\"function\\\") {\\n          var wrapped = function(e) {\\n            var rv = value.call(this, e);\\n            if (rv === false) e.preventDefault(); else if (name === \\\"onbeforeunload\\\" && typeof rv === \\\"string\\\") e.returnValue = rv;\\n          };\\n          this.addEventListener(eventType, wrapped, false);\\n          inlineEventHandlers[name] = {\\n            value: value,\\n            wrapped: wrapped\\n          };\\n        }\\n      };\\n    }\\n    scope.elementFromPoint = elementFromPoint;\\n    scope.getEventHandlerGetter = getEventHandlerGetter;\\n    scope.getEventHandlerSetter = getEventHandlerSetter;\\n    scope.wrapEventTargetMethods = wrapEventTargetMethods;\\n    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\\n    scope.wrappers.CustomEvent = CustomEvent;\\n    scope.wrappers.Event = Event;\\n    scope.wrappers.EventTarget = EventTarget;\\n    scope.wrappers.FocusEvent = FocusEvent;\\n    scope.wrappers.MouseEvent = MouseEvent;\\n    scope.wrappers.UIEvent = UIEvent;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var UIEvent = scope.wrappers.UIEvent;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrap = scope.wrap;\\n    var OriginalTouchEvent = window.TouchEvent;\\n    if (!OriginalTouchEvent) return;\\n    var nativeEvent;\\n    try {\\n      nativeEvent = document.createEvent(\\\"TouchEvent\\\");\\n    } catch (ex) {\\n      return;\\n    }\\n    var nonEnumDescriptor = {\\n      enumerable: false\\n    };\\n    function nonEnum(obj, prop) {\\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\\n    }\\n    function Touch(impl) {\\n      setWrapper(impl, this);\\n    }\\n    Touch.prototype = {\\n      get target() {\\n        return wrap(unsafeUnwrap(this).target);\\n      }\\n    };\\n    var descr = {\\n      configurable: true,\\n      enumerable: true,\\n      get: null\\n    };\\n    [ \\\"clientX\\\", \\\"clientY\\\", \\\"screenX\\\", \\\"screenY\\\", \\\"pageX\\\", \\\"pageY\\\", \\\"identifier\\\", \\\"webkitRadiusX\\\", \\\"webkitRadiusY\\\", \\\"webkitRotationAngle\\\", \\\"webkitForce\\\" ].forEach(function(name) {\\n      descr.get = function() {\\n        return unsafeUnwrap(this)[name];\\n      };\\n      Object.defineProperty(Touch.prototype, name, descr);\\n    });\\n    function TouchList() {\\n      this.length = 0;\\n      nonEnum(this, \\\"length\\\");\\n    }\\n    TouchList.prototype = {\\n      item: function(index) {\\n        return this[index];\\n      }\\n    };\\n    function wrapTouchList(nativeTouchList) {\\n      var list = new TouchList();\\n      for (var i = 0; i < nativeTouchList.length; i++) {\\n        list[i] = new Touch(nativeTouchList[i]);\\n      }\\n      list.length = i;\\n      return list;\\n    }\\n    function TouchEvent(impl) {\\n      UIEvent.call(this, impl);\\n    }\\n    TouchEvent.prototype = Object.create(UIEvent.prototype);\\n    mixin(TouchEvent.prototype, {\\n      get touches() {\\n        return wrapTouchList(unsafeUnwrap(this).touches);\\n      },\\n      get targetTouches() {\\n        return wrapTouchList(unsafeUnwrap(this).targetTouches);\\n      },\\n      get changedTouches() {\\n        return wrapTouchList(unsafeUnwrap(this).changedTouches);\\n      },\\n      initTouchEvent: function() {\\n        throw new Error(\\\"Not implemented\\\");\\n      }\\n    });\\n    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\\n    scope.wrappers.Touch = Touch;\\n    scope.wrappers.TouchEvent = TouchEvent;\\n    scope.wrappers.TouchList = TouchList;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrap = scope.wrap;\\n    var nonEnumDescriptor = {\\n      enumerable: false\\n    };\\n    function nonEnum(obj, prop) {\\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\\n    }\\n    function NodeList() {\\n      this.length = 0;\\n      nonEnum(this, \\\"length\\\");\\n    }\\n    NodeList.prototype = {\\n      item: function(index) {\\n        return this[index];\\n      }\\n    };\\n    nonEnum(NodeList.prototype, \\\"item\\\");\\n    function wrapNodeList(list) {\\n      if (list == null) return list;\\n      var wrapperList = new NodeList();\\n      for (var i = 0, length = list.length; i < length; i++) {\\n        wrapperList[i] = wrap(list[i]);\\n      }\\n      wrapperList.length = length;\\n      return wrapperList;\\n    }\\n    function addWrapNodeListMethod(wrapperConstructor, name) {\\n      wrapperConstructor.prototype[name] = function() {\\n        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\\n      };\\n    }\\n    scope.wrappers.NodeList = NodeList;\\n    scope.addWrapNodeListMethod = addWrapNodeListMethod;\\n    scope.wrapNodeList = wrapNodeList;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    scope.wrapHTMLCollection = scope.wrapNodeList;\\n    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var EventTarget = scope.wrappers.EventTarget;\\n    var NodeList = scope.wrappers.NodeList;\\n    var TreeScope = scope.TreeScope;\\n    var assert = scope.assert;\\n    var defineWrapGetter = scope.defineWrapGetter;\\n    var enqueueMutation = scope.enqueueMutation;\\n    var getTreeScope = scope.getTreeScope;\\n    var isWrapper = scope.isWrapper;\\n    var mixin = scope.mixin;\\n    var registerTransientObservers = scope.registerTransientObservers;\\n    var registerWrapper = scope.registerWrapper;\\n    var setTreeScope = scope.setTreeScope;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var wrapIfNeeded = scope.wrapIfNeeded;\\n    var wrappers = scope.wrappers;\\n    function assertIsNodeWrapper(node) {\\n      assert(node instanceof Node);\\n    }\\n    function createOneElementNodeList(node) {\\n      var nodes = new NodeList();\\n      nodes[0] = node;\\n      nodes.length = 1;\\n      return nodes;\\n    }\\n    var surpressMutations = false;\\n    function enqueueRemovalForInsertedNodes(node, parent, nodes) {\\n      enqueueMutation(parent, \\\"childList\\\", {\\n        removedNodes: nodes,\\n        previousSibling: node.previousSibling,\\n        nextSibling: node.nextSibling\\n      });\\n    }\\n    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\\n      enqueueMutation(df, \\\"childList\\\", {\\n        removedNodes: nodes\\n      });\\n    }\\n    function collectNodes(node, parentNode, previousNode, nextNode) {\\n      if (node instanceof DocumentFragment) {\\n        var nodes = collectNodesForDocumentFragment(node);\\n        surpressMutations = true;\\n        for (var i = nodes.length - 1; i >= 0; i--) {\\n          node.removeChild(nodes[i]);\\n          nodes[i].parentNode_ = parentNode;\\n        }\\n        surpressMutations = false;\\n        for (var i = 0; i < nodes.length; i++) {\\n          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\\n          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\\n        }\\n        if (previousNode) previousNode.nextSibling_ = nodes[0];\\n        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];\\n        return nodes;\\n      }\\n      var nodes = createOneElementNodeList(node);\\n      var oldParent = node.parentNode;\\n      if (oldParent) {\\n        oldParent.removeChild(node);\\n      }\\n      node.parentNode_ = parentNode;\\n      node.previousSibling_ = previousNode;\\n      node.nextSibling_ = nextNode;\\n      if (previousNode) previousNode.nextSibling_ = node;\\n      if (nextNode) nextNode.previousSibling_ = node;\\n      return nodes;\\n    }\\n    function collectNodesNative(node) {\\n      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);\\n      var nodes = createOneElementNodeList(node);\\n      var oldParent = node.parentNode;\\n      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);\\n      return nodes;\\n    }\\n    function collectNodesForDocumentFragment(node) {\\n      var nodes = new NodeList();\\n      var i = 0;\\n      for (var child = node.firstChild; child; child = child.nextSibling) {\\n        nodes[i++] = child;\\n      }\\n      nodes.length = i;\\n      enqueueRemovalForInsertedDocumentFragment(node, nodes);\\n      return nodes;\\n    }\\n    function snapshotNodeList(nodeList) {\\n      return nodeList;\\n    }\\n    function nodeWasAdded(node, treeScope) {\\n      setTreeScope(node, treeScope);\\n      node.nodeIsInserted_();\\n    }\\n    function nodesWereAdded(nodes, parent) {\\n      var treeScope = getTreeScope(parent);\\n      for (var i = 0; i < nodes.length; i++) {\\n        nodeWasAdded(nodes[i], treeScope);\\n      }\\n    }\\n    function nodeWasRemoved(node) {\\n      setTreeScope(node, new TreeScope(node, null));\\n    }\\n    function nodesWereRemoved(nodes) {\\n      for (var i = 0; i < nodes.length; i++) {\\n        nodeWasRemoved(nodes[i]);\\n      }\\n    }\\n    function ensureSameOwnerDocument(parent, child) {\\n      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;\\n      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);\\n    }\\n    function adoptNodesIfNeeded(owner, nodes) {\\n      if (!nodes.length) return;\\n      var ownerDoc = owner.ownerDocument;\\n      if (ownerDoc === nodes[0].ownerDocument) return;\\n      for (var i = 0; i < nodes.length; i++) {\\n        scope.adoptNodeNoRemove(nodes[i], ownerDoc);\\n      }\\n    }\\n    function unwrapNodesForInsertion(owner, nodes) {\\n      adoptNodesIfNeeded(owner, nodes);\\n      var length = nodes.length;\\n      if (length === 1) return unwrap(nodes[0]);\\n      var df = unwrap(owner.ownerDocument.createDocumentFragment());\\n      for (var i = 0; i < length; i++) {\\n        df.appendChild(unwrap(nodes[i]));\\n      }\\n      return df;\\n    }\\n    function clearChildNodes(wrapper) {\\n      if (wrapper.firstChild_ !== undefined) {\\n        var child = wrapper.firstChild_;\\n        while (child) {\\n          var tmp = child;\\n          child = child.nextSibling_;\\n          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\\n        }\\n      }\\n      wrapper.firstChild_ = wrapper.lastChild_ = undefined;\\n    }\\n    function removeAllChildNodes(wrapper) {\\n      if (wrapper.invalidateShadowRenderer()) {\\n        var childWrapper = wrapper.firstChild;\\n        while (childWrapper) {\\n          assert(childWrapper.parentNode === wrapper);\\n          var nextSibling = childWrapper.nextSibling;\\n          var childNode = unwrap(childWrapper);\\n          var parentNode = childNode.parentNode;\\n          if (parentNode) originalRemoveChild.call(parentNode, childNode);\\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;\\n          childWrapper = nextSibling;\\n        }\\n        wrapper.firstChild_ = wrapper.lastChild_ = null;\\n      } else {\\n        var node = unwrap(wrapper);\\n        var child = node.firstChild;\\n        var nextSibling;\\n        while (child) {\\n          nextSibling = child.nextSibling;\\n          originalRemoveChild.call(node, child);\\n          child = nextSibling;\\n        }\\n      }\\n    }\\n    function invalidateParent(node) {\\n      var p = node.parentNode;\\n      return p && p.invalidateShadowRenderer();\\n    }\\n    function cleanupNodes(nodes) {\\n      for (var i = 0, n; i < nodes.length; i++) {\\n        n = nodes[i];\\n        n.parentNode.removeChild(n);\\n      }\\n    }\\n    var originalImportNode = document.importNode;\\n    var originalCloneNode = window.Node.prototype.cloneNode;\\n    function cloneNode(node, deep, opt_doc) {\\n      var clone;\\n      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\\n      if (deep) {\\n        for (var child = node.firstChild; child; child = child.nextSibling) {\\n          clone.appendChild(cloneNode(child, true, opt_doc));\\n        }\\n        if (node instanceof wrappers.HTMLTemplateElement) {\\n          var cloneContent = clone.content;\\n          for (var child = node.content.firstChild; child; child = child.nextSibling) {\\n            cloneContent.appendChild(cloneNode(child, true, opt_doc));\\n          }\\n        }\\n      }\\n      return clone;\\n    }\\n    function contains(self, child) {\\n      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;\\n      for (var node = child; node; node = node.parentNode) {\\n        if (node === self) return true;\\n      }\\n      return false;\\n    }\\n    var OriginalNode = window.Node;\\n    function Node(original) {\\n      assert(original instanceof OriginalNode);\\n      EventTarget.call(this, original);\\n      this.parentNode_ = undefined;\\n      this.firstChild_ = undefined;\\n      this.lastChild_ = undefined;\\n      this.nextSibling_ = undefined;\\n      this.previousSibling_ = undefined;\\n      this.treeScope_ = undefined;\\n    }\\n    var OriginalDocumentFragment = window.DocumentFragment;\\n    var originalAppendChild = OriginalNode.prototype.appendChild;\\n    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;\\n    var originalIsEqualNode = OriginalNode.prototype.isEqualNode;\\n    var originalInsertBefore = OriginalNode.prototype.insertBefore;\\n    var originalRemoveChild = OriginalNode.prototype.removeChild;\\n    var originalReplaceChild = OriginalNode.prototype.replaceChild;\\n    var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);\\n    var removeChildOriginalHelper = isIEOrEdge ? function(parent, child) {\\n      try {\\n        originalRemoveChild.call(parent, child);\\n      } catch (ex) {\\n        if (!(parent instanceof OriginalDocumentFragment)) throw ex;\\n      }\\n    } : function(parent, child) {\\n      originalRemoveChild.call(parent, child);\\n    };\\n    Node.prototype = Object.create(EventTarget.prototype);\\n    mixin(Node.prototype, {\\n      appendChild: function(childWrapper) {\\n        return this.insertBefore(childWrapper, null);\\n      },\\n      insertBefore: function(childWrapper, refWrapper) {\\n        assertIsNodeWrapper(childWrapper);\\n        var refNode;\\n        if (refWrapper) {\\n          if (isWrapper(refWrapper)) {\\n            refNode = unwrap(refWrapper);\\n          } else {\\n            refNode = refWrapper;\\n            refWrapper = wrap(refNode);\\n          }\\n        } else {\\n          refWrapper = null;\\n          refNode = null;\\n        }\\n        refWrapper && assert(refWrapper.parentNode === this);\\n        var nodes;\\n        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;\\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);\\n        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\\n        if (useNative) {\\n          ensureSameOwnerDocument(this, childWrapper);\\n          clearChildNodes(this);\\n          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\\n        } else {\\n          if (!previousNode) this.firstChild_ = nodes[0];\\n          if (!refWrapper) {\\n            this.lastChild_ = nodes[nodes.length - 1];\\n            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;\\n          }\\n          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\\n          if (parentNode) {\\n            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);\\n          } else {\\n            adoptNodesIfNeeded(this, nodes);\\n          }\\n        }\\n        enqueueMutation(this, \\\"childList\\\", {\\n          addedNodes: nodes,\\n          nextSibling: refWrapper,\\n          previousSibling: previousNode\\n        });\\n        nodesWereAdded(nodes, this);\\n        return childWrapper;\\n      },\\n      removeChild: function(childWrapper) {\\n        assertIsNodeWrapper(childWrapper);\\n        if (childWrapper.parentNode !== this) {\\n          var found = false;\\n          var childNodes = this.childNodes;\\n          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {\\n            if (ieChild === childWrapper) {\\n              found = true;\\n              break;\\n            }\\n          }\\n          if (!found) {\\n            throw new Error(\\\"NotFoundError\\\");\\n          }\\n        }\\n        var childNode = unwrap(childWrapper);\\n        var childWrapperNextSibling = childWrapper.nextSibling;\\n        var childWrapperPreviousSibling = childWrapper.previousSibling;\\n        if (this.invalidateShadowRenderer()) {\\n          var thisFirstChild = this.firstChild;\\n          var thisLastChild = this.lastChild;\\n          var parentNode = childNode.parentNode;\\n          if (parentNode) removeChildOriginalHelper(parentNode, childNode);\\n          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;\\n          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;\\n          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\\n          if (childWrapperNextSibling) {\\n            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;\\n          }\\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;\\n        } else {\\n          clearChildNodes(this);\\n          removeChildOriginalHelper(unsafeUnwrap(this), childNode);\\n        }\\n        if (!surpressMutations) {\\n          enqueueMutation(this, \\\"childList\\\", {\\n            removedNodes: createOneElementNodeList(childWrapper),\\n            nextSibling: childWrapperNextSibling,\\n            previousSibling: childWrapperPreviousSibling\\n          });\\n        }\\n        registerTransientObservers(this, childWrapper);\\n        return childWrapper;\\n      },\\n      replaceChild: function(newChildWrapper, oldChildWrapper) {\\n        assertIsNodeWrapper(newChildWrapper);\\n        var oldChildNode;\\n        if (isWrapper(oldChildWrapper)) {\\n          oldChildNode = unwrap(oldChildWrapper);\\n        } else {\\n          oldChildNode = oldChildWrapper;\\n          oldChildWrapper = wrap(oldChildNode);\\n        }\\n        if (oldChildWrapper.parentNode !== this) {\\n          throw new Error(\\\"NotFoundError\\\");\\n        }\\n        var nextNode = oldChildWrapper.nextSibling;\\n        var previousNode = oldChildWrapper.previousSibling;\\n        var nodes;\\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);\\n        if (useNative) {\\n          nodes = collectNodesNative(newChildWrapper);\\n        } else {\\n          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;\\n          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\\n        }\\n        if (!useNative) {\\n          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];\\n          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];\\n          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;\\n          if (oldChildNode.parentNode) {\\n            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);\\n          }\\n        } else {\\n          ensureSameOwnerDocument(this, newChildWrapper);\\n          clearChildNodes(this);\\n          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);\\n        }\\n        enqueueMutation(this, \\\"childList\\\", {\\n          addedNodes: nodes,\\n          removedNodes: createOneElementNodeList(oldChildWrapper),\\n          nextSibling: nextNode,\\n          previousSibling: previousNode\\n        });\\n        nodeWasRemoved(oldChildWrapper);\\n        nodesWereAdded(nodes, this);\\n        return oldChildWrapper;\\n      },\\n      nodeIsInserted_: function() {\\n        for (var child = this.firstChild; child; child = child.nextSibling) {\\n          child.nodeIsInserted_();\\n        }\\n      },\\n      hasChildNodes: function() {\\n        return this.firstChild !== null;\\n      },\\n      get parentNode() {\\n        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\\n      },\\n      get firstChild() {\\n        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\\n      },\\n      get lastChild() {\\n        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\\n      },\\n      get nextSibling() {\\n        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\\n      },\\n      get previousSibling() {\\n        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\\n      },\\n      get parentElement() {\\n        var p = this.parentNode;\\n        while (p && p.nodeType !== Node.ELEMENT_NODE) {\\n          p = p.parentNode;\\n        }\\n        return p;\\n      },\\n      get textContent() {\\n        var s = \\\"\\\";\\n        for (var child = this.firstChild; child; child = child.nextSibling) {\\n          if (child.nodeType != Node.COMMENT_NODE) {\\n            s += child.textContent;\\n          }\\n        }\\n        return s;\\n      },\\n      set textContent(textContent) {\\n        if (textContent == null) textContent = \\\"\\\";\\n        var removedNodes = snapshotNodeList(this.childNodes);\\n        if (this.invalidateShadowRenderer()) {\\n          removeAllChildNodes(this);\\n          if (textContent !== \\\"\\\") {\\n            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\\n            this.appendChild(textNode);\\n          }\\n        } else {\\n          clearChildNodes(this);\\n          unsafeUnwrap(this).textContent = textContent;\\n        }\\n        var addedNodes = snapshotNodeList(this.childNodes);\\n        enqueueMutation(this, \\\"childList\\\", {\\n          addedNodes: addedNodes,\\n          removedNodes: removedNodes\\n        });\\n        nodesWereRemoved(removedNodes);\\n        nodesWereAdded(addedNodes, this);\\n      },\\n      get childNodes() {\\n        var wrapperList = new NodeList();\\n        var i = 0;\\n        for (var child = this.firstChild; child; child = child.nextSibling) {\\n          wrapperList[i++] = child;\\n        }\\n        wrapperList.length = i;\\n        return wrapperList;\\n      },\\n      cloneNode: function(deep) {\\n        return cloneNode(this, deep);\\n      },\\n      contains: function(child) {\\n        return contains(this, wrapIfNeeded(child));\\n      },\\n      compareDocumentPosition: function(otherNode) {\\n        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\\n      },\\n      isEqualNode: function(otherNode) {\\n        return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\\n      },\\n      normalize: function() {\\n        var nodes = snapshotNodeList(this.childNodes);\\n        var remNodes = [];\\n        var s = \\\"\\\";\\n        var modNode;\\n        for (var i = 0, n; i < nodes.length; i++) {\\n          n = nodes[i];\\n          if (n.nodeType === Node.TEXT_NODE) {\\n            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {\\n              s += n.data;\\n              remNodes.push(n);\\n            }\\n          } else {\\n            if (modNode && remNodes.length) {\\n              modNode.data += s;\\n              cleanupNodes(remNodes);\\n            }\\n            remNodes = [];\\n            s = \\\"\\\";\\n            modNode = null;\\n            if (n.childNodes.length) n.normalize();\\n          }\\n        }\\n        if (modNode && remNodes.length) {\\n          modNode.data += s;\\n          cleanupNodes(remNodes);\\n        }\\n      }\\n    });\\n    defineWrapGetter(Node, \\\"ownerDocument\\\");\\n    registerWrapper(OriginalNode, Node, document.createDocumentFragment());\\n    delete Node.prototype.querySelector;\\n    delete Node.prototype.querySelectorAll;\\n    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\\n    scope.cloneNode = cloneNode;\\n    scope.nodeWasAdded = nodeWasAdded;\\n    scope.nodeWasRemoved = nodeWasRemoved;\\n    scope.nodesWereAdded = nodesWereAdded;\\n    scope.nodesWereRemoved = nodesWereRemoved;\\n    scope.originalInsertBefore = originalInsertBefore;\\n    scope.originalRemoveChild = originalRemoveChild;\\n    scope.snapshotNodeList = snapshotNodeList;\\n    scope.wrappers.Node = Node;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLCollection = scope.wrappers.HTMLCollection;\\n    var NodeList = scope.wrappers.NodeList;\\n    var getTreeScope = scope.getTreeScope;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrap = scope.wrap;\\n    var originalDocumentQuerySelector = document.querySelector;\\n    var originalElementQuerySelector = document.documentElement.querySelector;\\n    var originalDocumentQuerySelectorAll = document.querySelectorAll;\\n    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\\n    var originalDocumentGetElementsByTagName = document.getElementsByTagName;\\n    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\\n    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\\n    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\\n    var OriginalElement = window.Element;\\n    var OriginalDocument = window.HTMLDocument || window.Document;\\n    function filterNodeList(list, index, result, deep) {\\n      var wrappedItem = null;\\n      var root = null;\\n      for (var i = 0, length = list.length; i < length; i++) {\\n        wrappedItem = wrap(list[i]);\\n        if (!deep && (root = getTreeScope(wrappedItem).root)) {\\n          if (root instanceof scope.wrappers.ShadowRoot) {\\n            continue;\\n          }\\n        }\\n        result[index++] = wrappedItem;\\n      }\\n      return index;\\n    }\\n    function shimSelector(selector) {\\n      return String(selector).replace(/\\\\/deep\\\\/|::shadow|>>>/g, \\\" \\\");\\n    }\\n    function shimMatchesSelector(selector) {\\n      return String(selector).replace(/:host\\\\(([^\\\\s]+)\\\\)/g, \\\"$1\\\").replace(/([^\\\\s]):host/g, \\\"$1\\\").replace(\\\":host\\\", \\\"*\\\").replace(/\\\\^|\\\\/shadow\\\\/|\\\\/shadow-deep\\\\/|::shadow|\\\\/deep\\\\/|::content|>>>/g, \\\" \\\");\\n    }\\n    function findOne(node, selector) {\\n      var m, el = node.firstElementChild;\\n      while (el) {\\n        if (el.matches(selector)) return el;\\n        m = findOne(el, selector);\\n        if (m) return m;\\n        el = el.nextElementSibling;\\n      }\\n      return null;\\n    }\\n    function matchesSelector(el, selector) {\\n      return el.matches(selector);\\n    }\\n    var XHTML_NS = \\\"http://www.w3.org/1999/xhtml\\\";\\n    function matchesTagName(el, localName, localNameLowerCase) {\\n      var ln = el.localName;\\n      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\\n    }\\n    function matchesEveryThing() {\\n      return true;\\n    }\\n    function matchesLocalNameOnly(el, ns, localName) {\\n      return el.localName === localName;\\n    }\\n    function matchesNameSpace(el, ns) {\\n      return el.namespaceURI === ns;\\n    }\\n    function matchesLocalNameNS(el, ns, localName) {\\n      return el.namespaceURI === ns && el.localName === localName;\\n    }\\n    function findElements(node, index, result, p, arg0, arg1) {\\n      var el = node.firstElementChild;\\n      while (el) {\\n        if (p(el, arg0, arg1)) result[index++] = el;\\n        index = findElements(el, index, result, p, arg0, arg1);\\n        el = el.nextElementSibling;\\n      }\\n      return index;\\n    }\\n    function querySelectorAllFiltered(p, index, result, selector, deep) {\\n      var target = unsafeUnwrap(this);\\n      var list;\\n      var root = getTreeScope(this).root;\\n      if (root instanceof scope.wrappers.ShadowRoot) {\\n        return findElements(this, index, result, p, selector, null);\\n      } else if (target instanceof OriginalElement) {\\n        list = originalElementQuerySelectorAll.call(target, selector);\\n      } else if (target instanceof OriginalDocument) {\\n        list = originalDocumentQuerySelectorAll.call(target, selector);\\n      } else {\\n        return findElements(this, index, result, p, selector, null);\\n      }\\n      return filterNodeList(list, index, result, deep);\\n    }\\n    var SelectorsInterface = {\\n      querySelector: function(selector) {\\n        var shimmed = shimSelector(selector);\\n        var deep = shimmed !== selector;\\n        selector = shimmed;\\n        var target = unsafeUnwrap(this);\\n        var wrappedItem;\\n        var root = getTreeScope(this).root;\\n        if (root instanceof scope.wrappers.ShadowRoot) {\\n          return findOne(this, selector);\\n        } else if (target instanceof OriginalElement) {\\n          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\\n        } else if (target instanceof OriginalDocument) {\\n          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\\n        } else {\\n          return findOne(this, selector);\\n        }\\n        if (!wrappedItem) {\\n          return wrappedItem;\\n        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\\n          if (root instanceof scope.wrappers.ShadowRoot) {\\n            return findOne(this, selector);\\n          }\\n        }\\n        return wrappedItem;\\n      },\\n      querySelectorAll: function(selector) {\\n        var shimmed = shimSelector(selector);\\n        var deep = shimmed !== selector;\\n        selector = shimmed;\\n        var result = new NodeList();\\n        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);\\n        return result;\\n      }\\n    };\\n    var MatchesInterface = {\\n      matches: function(selector) {\\n        selector = shimMatchesSelector(selector);\\n        return scope.originalMatches.call(unsafeUnwrap(this), selector);\\n      }\\n    };\\n    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {\\n      var target = unsafeUnwrap(this);\\n      var list;\\n      var root = getTreeScope(this).root;\\n      if (root instanceof scope.wrappers.ShadowRoot) {\\n        return findElements(this, index, result, p, localName, lowercase);\\n      } else if (target instanceof OriginalElement) {\\n        list = originalElementGetElementsByTagName.call(target, localName, lowercase);\\n      } else if (target instanceof OriginalDocument) {\\n        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);\\n      } else {\\n        return findElements(this, index, result, p, localName, lowercase);\\n      }\\n      return filterNodeList(list, index, result, false);\\n    }\\n    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\\n      var target = unsafeUnwrap(this);\\n      var list;\\n      var root = getTreeScope(this).root;\\n      if (root instanceof scope.wrappers.ShadowRoot) {\\n        return findElements(this, index, result, p, ns, localName);\\n      } else if (target instanceof OriginalElement) {\\n        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\\n      } else if (target instanceof OriginalDocument) {\\n        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\\n      } else {\\n        return findElements(this, index, result, p, ns, localName);\\n      }\\n      return filterNodeList(list, index, result, false);\\n    }\\n    var GetElementsByInterface = {\\n      getElementsByTagName: function(localName) {\\n        var result = new HTMLCollection();\\n        var match = localName === \\\"*\\\" ? matchesEveryThing : matchesTagName;\\n        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());\\n        return result;\\n      },\\n      getElementsByClassName: function(className) {\\n        return this.querySelectorAll(\\\".\\\" + className);\\n      },\\n      getElementsByTagNameNS: function(ns, localName) {\\n        var result = new HTMLCollection();\\n        var match = null;\\n        if (ns === \\\"*\\\") {\\n          match = localName === \\\"*\\\" ? matchesEveryThing : matchesLocalNameOnly;\\n        } else {\\n          match = localName === \\\"*\\\" ? matchesNameSpace : matchesLocalNameNS;\\n        }\\n        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);\\n        return result;\\n      }\\n    };\\n    scope.GetElementsByInterface = GetElementsByInterface;\\n    scope.SelectorsInterface = SelectorsInterface;\\n    scope.MatchesInterface = MatchesInterface;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var NodeList = scope.wrappers.NodeList;\\n    function forwardElement(node) {\\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\\n        node = node.nextSibling;\\n      }\\n      return node;\\n    }\\n    function backwardsElement(node) {\\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\\n        node = node.previousSibling;\\n      }\\n      return node;\\n    }\\n    var ParentNodeInterface = {\\n      get firstElementChild() {\\n        return forwardElement(this.firstChild);\\n      },\\n      get lastElementChild() {\\n        return backwardsElement(this.lastChild);\\n      },\\n      get childElementCount() {\\n        var count = 0;\\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\\n          count++;\\n        }\\n        return count;\\n      },\\n      get children() {\\n        var wrapperList = new NodeList();\\n        var i = 0;\\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\\n          wrapperList[i++] = child;\\n        }\\n        wrapperList.length = i;\\n        return wrapperList;\\n      },\\n      remove: function() {\\n        var p = this.parentNode;\\n        if (p) p.removeChild(this);\\n      }\\n    };\\n    var ChildNodeInterface = {\\n      get nextElementSibling() {\\n        return forwardElement(this.nextSibling);\\n      },\\n      get previousElementSibling() {\\n        return backwardsElement(this.previousSibling);\\n      }\\n    };\\n    var NonElementParentNodeInterface = {\\n      getElementById: function(id) {\\n        if (/[ \\\\t\\\\n\\\\r\\\\f]/.test(id)) return null;\\n        return this.querySelector('[id=\\\"' + id + '\\\"]');\\n      }\\n    };\\n    scope.ChildNodeInterface = ChildNodeInterface;\\n    scope.NonElementParentNodeInterface = NonElementParentNodeInterface;\\n    scope.ParentNodeInterface = ParentNodeInterface;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var ChildNodeInterface = scope.ChildNodeInterface;\\n    var Node = scope.wrappers.Node;\\n    var enqueueMutation = scope.enqueueMutation;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var OriginalCharacterData = window.CharacterData;\\n    function CharacterData(node) {\\n      Node.call(this, node);\\n    }\\n    CharacterData.prototype = Object.create(Node.prototype);\\n    mixin(CharacterData.prototype, {\\n      get nodeValue() {\\n        return this.data;\\n      },\\n      set nodeValue(data) {\\n        this.data = data;\\n      },\\n      get textContent() {\\n        return this.data;\\n      },\\n      set textContent(value) {\\n        this.data = value;\\n      },\\n      get data() {\\n        return unsafeUnwrap(this).data;\\n      },\\n      set data(value) {\\n        var oldValue = unsafeUnwrap(this).data;\\n        enqueueMutation(this, \\\"characterData\\\", {\\n          oldValue: oldValue\\n        });\\n        unsafeUnwrap(this).data = value;\\n      }\\n    });\\n    mixin(CharacterData.prototype, ChildNodeInterface);\\n    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(\\\"\\\"));\\n    scope.wrappers.CharacterData = CharacterData;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var CharacterData = scope.wrappers.CharacterData;\\n    var enqueueMutation = scope.enqueueMutation;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    function toUInt32(x) {\\n      return x >>> 0;\\n    }\\n    var OriginalText = window.Text;\\n    function Text(node) {\\n      CharacterData.call(this, node);\\n    }\\n    Text.prototype = Object.create(CharacterData.prototype);\\n    mixin(Text.prototype, {\\n      splitText: function(offset) {\\n        offset = toUInt32(offset);\\n        var s = this.data;\\n        if (offset > s.length) throw new Error(\\\"IndexSizeError\\\");\\n        var head = s.slice(0, offset);\\n        var tail = s.slice(offset);\\n        this.data = head;\\n        var newTextNode = this.ownerDocument.createTextNode(tail);\\n        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);\\n        return newTextNode;\\n      }\\n    });\\n    registerWrapper(OriginalText, Text, document.createTextNode(\\\"\\\"));\\n    scope.wrappers.Text = Text;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    if (!window.DOMTokenList) {\\n      console.warn(\\\"Missing DOMTokenList prototype, please include a \\\" + \\\"compatible classList polyfill such as http://goo.gl/uTcepH.\\\");\\n      return;\\n    }\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var enqueueMutation = scope.enqueueMutation;\\n    function getClass(el) {\\n      return unsafeUnwrap(el).getAttribute(\\\"class\\\");\\n    }\\n    function enqueueClassAttributeChange(el, oldValue) {\\n      enqueueMutation(el, \\\"attributes\\\", {\\n        name: \\\"class\\\",\\n        namespace: null,\\n        oldValue: oldValue\\n      });\\n    }\\n    function invalidateClass(el) {\\n      scope.invalidateRendererBasedOnAttribute(el, \\\"class\\\");\\n    }\\n    function changeClass(tokenList, method, args) {\\n      var ownerElement = tokenList.ownerElement_;\\n      if (ownerElement == null) {\\n        return method.apply(tokenList, args);\\n      }\\n      var oldValue = getClass(ownerElement);\\n      var retv = method.apply(tokenList, args);\\n      if (getClass(ownerElement) !== oldValue) {\\n        enqueueClassAttributeChange(ownerElement, oldValue);\\n        invalidateClass(ownerElement);\\n      }\\n      return retv;\\n    }\\n    var oldAdd = DOMTokenList.prototype.add;\\n    DOMTokenList.prototype.add = function() {\\n      changeClass(this, oldAdd, arguments);\\n    };\\n    var oldRemove = DOMTokenList.prototype.remove;\\n    DOMTokenList.prototype.remove = function() {\\n      changeClass(this, oldRemove, arguments);\\n    };\\n    var oldToggle = DOMTokenList.prototype.toggle;\\n    DOMTokenList.prototype.toggle = function() {\\n      return changeClass(this, oldToggle, arguments);\\n    };\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var ChildNodeInterface = scope.ChildNodeInterface;\\n    var GetElementsByInterface = scope.GetElementsByInterface;\\n    var Node = scope.wrappers.Node;\\n    var ParentNodeInterface = scope.ParentNodeInterface;\\n    var SelectorsInterface = scope.SelectorsInterface;\\n    var MatchesInterface = scope.MatchesInterface;\\n    var addWrapNodeListMethod = scope.addWrapNodeListMethod;\\n    var enqueueMutation = scope.enqueueMutation;\\n    var mixin = scope.mixin;\\n    var oneOf = scope.oneOf;\\n    var registerWrapper = scope.registerWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrappers = scope.wrappers;\\n    var OriginalElement = window.Element;\\n    var matchesNames = [ \\\"matches\\\", \\\"mozMatchesSelector\\\", \\\"msMatchesSelector\\\", \\\"webkitMatchesSelector\\\" ].filter(function(name) {\\n      return OriginalElement.prototype[name];\\n    });\\n    var matchesName = matchesNames[0];\\n    var originalMatches = OriginalElement.prototype[matchesName];\\n    function invalidateRendererBasedOnAttribute(element, name) {\\n      var p = element.parentNode;\\n      if (!p || !p.shadowRoot) return;\\n      var renderer = scope.getRendererForHost(p);\\n      if (renderer.dependsOnAttribute(name)) renderer.invalidate();\\n    }\\n    function enqueAttributeChange(element, name, oldValue) {\\n      enqueueMutation(element, \\\"attributes\\\", {\\n        name: name,\\n        namespace: null,\\n        oldValue: oldValue\\n      });\\n    }\\n    var classListTable = new WeakMap();\\n    function Element(node) {\\n      Node.call(this, node);\\n    }\\n    Element.prototype = Object.create(Node.prototype);\\n    mixin(Element.prototype, {\\n      createShadowRoot: function() {\\n        var newShadowRoot = new wrappers.ShadowRoot(this);\\n        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\\n        var renderer = scope.getRendererForHost(this);\\n        renderer.invalidate();\\n        return newShadowRoot;\\n      },\\n      get shadowRoot() {\\n        return unsafeUnwrap(this).polymerShadowRoot_ || null;\\n      },\\n      setAttribute: function(name, value) {\\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\\n        unsafeUnwrap(this).setAttribute(name, value);\\n        enqueAttributeChange(this, name, oldValue);\\n        invalidateRendererBasedOnAttribute(this, name);\\n      },\\n      removeAttribute: function(name) {\\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\\n        unsafeUnwrap(this).removeAttribute(name);\\n        enqueAttributeChange(this, name, oldValue);\\n        invalidateRendererBasedOnAttribute(this, name);\\n      },\\n      get classList() {\\n        var list = classListTable.get(this);\\n        if (!list) {\\n          list = unsafeUnwrap(this).classList;\\n          if (!list) return;\\n          list.ownerElement_ = this;\\n          classListTable.set(this, list);\\n        }\\n        return list;\\n      },\\n      get className() {\\n        return unsafeUnwrap(this).className;\\n      },\\n      set className(v) {\\n        this.setAttribute(\\\"class\\\", v);\\n      },\\n      get id() {\\n        return unsafeUnwrap(this).id;\\n      },\\n      set id(v) {\\n        this.setAttribute(\\\"id\\\", v);\\n      }\\n    });\\n    matchesNames.forEach(function(name) {\\n      if (name !== \\\"matches\\\") {\\n        Element.prototype[name] = function(selector) {\\n          return this.matches(selector);\\n        };\\n      }\\n    });\\n    if (OriginalElement.prototype.webkitCreateShadowRoot) {\\n      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\\n    }\\n    mixin(Element.prototype, ChildNodeInterface);\\n    mixin(Element.prototype, GetElementsByInterface);\\n    mixin(Element.prototype, ParentNodeInterface);\\n    mixin(Element.prototype, SelectorsInterface);\\n    mixin(Element.prototype, MatchesInterface);\\n    registerWrapper(OriginalElement, Element, document.createElementNS(null, \\\"x\\\"));\\n    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\\n    scope.matchesNames = matchesNames;\\n    scope.originalMatches = originalMatches;\\n    scope.wrappers.Element = Element;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var Element = scope.wrappers.Element;\\n    var defineGetter = scope.defineGetter;\\n    var enqueueMutation = scope.enqueueMutation;\\n    var mixin = scope.mixin;\\n    var nodesWereAdded = scope.nodesWereAdded;\\n    var nodesWereRemoved = scope.nodesWereRemoved;\\n    var registerWrapper = scope.registerWrapper;\\n    var snapshotNodeList = scope.snapshotNodeList;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var wrappers = scope.wrappers;\\n    var escapeAttrRegExp = /[&\\\\u00A0\\\"]/g;\\n    var escapeDataRegExp = /[&\\\\u00A0<>]/g;\\n    function escapeReplace(c) {\\n      switch (c) {\\n       case \\\"&\\\":\\n        return \\\"&amp;\\\";\\n\\n       case \\\"<\\\":\\n        return \\\"&lt;\\\";\\n\\n       case \\\">\\\":\\n        return \\\"&gt;\\\";\\n\\n       case '\\\"':\\n        return \\\"&quot;\\\";\\n\\n       case \\\"\\\":\\n        return \\\"&nbsp;\\\";\\n      }\\n    }\\n    function escapeAttr(s) {\\n      return s.replace(escapeAttrRegExp, escapeReplace);\\n    }\\n    function escapeData(s) {\\n      return s.replace(escapeDataRegExp, escapeReplace);\\n    }\\n    function makeSet(arr) {\\n      var set = {};\\n      for (var i = 0; i < arr.length; i++) {\\n        set[arr[i]] = true;\\n      }\\n      return set;\\n    }\\n    var voidElements = makeSet([ \\\"area\\\", \\\"base\\\", \\\"br\\\", \\\"col\\\", \\\"command\\\", \\\"embed\\\", \\\"hr\\\", \\\"img\\\", \\\"input\\\", \\\"keygen\\\", \\\"link\\\", \\\"meta\\\", \\\"param\\\", \\\"source\\\", \\\"track\\\", \\\"wbr\\\" ]);\\n    var plaintextParents = makeSet([ \\\"style\\\", \\\"script\\\", \\\"xmp\\\", \\\"iframe\\\", \\\"noembed\\\", \\\"noframes\\\", \\\"plaintext\\\", \\\"noscript\\\" ]);\\n    var XHTML_NS = \\\"http://www.w3.org/1999/xhtml\\\";\\n    function needsSelfClosingSlash(node) {\\n      if (node.namespaceURI !== XHTML_NS) return true;\\n      var doctype = node.ownerDocument.doctype;\\n      return doctype && doctype.publicId && doctype.systemId;\\n    }\\n    function getOuterHTML(node, parentNode) {\\n      switch (node.nodeType) {\\n       case Node.ELEMENT_NODE:\\n        var tagName = node.tagName.toLowerCase();\\n        var s = \\\"<\\\" + tagName;\\n        var attrs = node.attributes;\\n        for (var i = 0, attr; attr = attrs[i]; i++) {\\n          s += \\\" \\\" + attr.name + '=\\\"' + escapeAttr(attr.value) + '\\\"';\\n        }\\n        if (voidElements[tagName]) {\\n          if (needsSelfClosingSlash(node)) s += \\\"/\\\";\\n          return s + \\\">\\\";\\n        }\\n        return s + \\\">\\\" + getInnerHTML(node) + \\\"</\\\" + tagName + \\\">\\\";\\n\\n       case Node.TEXT_NODE:\\n        var data = node.data;\\n        if (parentNode && plaintextParents[parentNode.localName]) return data;\\n        return escapeData(data);\\n\\n       case Node.COMMENT_NODE:\\n        return \\\"<!--\\\" + node.data + \\\"-->\\\";\\n\\n       default:\\n        console.error(node);\\n        throw new Error(\\\"not implemented\\\");\\n      }\\n    }\\n    function getInnerHTML(node) {\\n      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;\\n      var s = \\\"\\\";\\n      for (var child = node.firstChild; child; child = child.nextSibling) {\\n        s += getOuterHTML(child, node);\\n      }\\n      return s;\\n    }\\n    function setInnerHTML(node, value, opt_tagName) {\\n      var tagName = opt_tagName || \\\"div\\\";\\n      node.textContent = \\\"\\\";\\n      var tempElement = unwrap(node.ownerDocument.createElement(tagName));\\n      tempElement.innerHTML = value;\\n      var firstChild;\\n      while (firstChild = tempElement.firstChild) {\\n        node.appendChild(wrap(firstChild));\\n      }\\n    }\\n    var oldIe = /MSIE/.test(navigator.userAgent);\\n    var OriginalHTMLElement = window.HTMLElement;\\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\\n    function HTMLElement(node) {\\n      Element.call(this, node);\\n    }\\n    HTMLElement.prototype = Object.create(Element.prototype);\\n    mixin(HTMLElement.prototype, {\\n      get innerHTML() {\\n        return getInnerHTML(this);\\n      },\\n      set innerHTML(value) {\\n        if (oldIe && plaintextParents[this.localName]) {\\n          this.textContent = value;\\n          return;\\n        }\\n        var removedNodes = snapshotNodeList(this.childNodes);\\n        if (this.invalidateShadowRenderer()) {\\n          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);\\n        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {\\n          setInnerHTML(this.content, value);\\n        } else {\\n          unsafeUnwrap(this).innerHTML = value;\\n        }\\n        var addedNodes = snapshotNodeList(this.childNodes);\\n        enqueueMutation(this, \\\"childList\\\", {\\n          addedNodes: addedNodes,\\n          removedNodes: removedNodes\\n        });\\n        nodesWereRemoved(removedNodes);\\n        nodesWereAdded(addedNodes, this);\\n      },\\n      get outerHTML() {\\n        return getOuterHTML(this, this.parentNode);\\n      },\\n      set outerHTML(value) {\\n        var p = this.parentNode;\\n        if (p) {\\n          p.invalidateShadowRenderer();\\n          var df = frag(p, value);\\n          p.replaceChild(df, this);\\n        }\\n      },\\n      insertAdjacentHTML: function(position, text) {\\n        var contextElement, refNode;\\n        switch (String(position).toLowerCase()) {\\n         case \\\"beforebegin\\\":\\n          contextElement = this.parentNode;\\n          refNode = this;\\n          break;\\n\\n         case \\\"afterend\\\":\\n          contextElement = this.parentNode;\\n          refNode = this.nextSibling;\\n          break;\\n\\n         case \\\"afterbegin\\\":\\n          contextElement = this;\\n          refNode = this.firstChild;\\n          break;\\n\\n         case \\\"beforeend\\\":\\n          contextElement = this;\\n          refNode = null;\\n          break;\\n\\n         default:\\n          return;\\n        }\\n        var df = frag(contextElement, text);\\n        contextElement.insertBefore(df, refNode);\\n      },\\n      get hidden() {\\n        return this.hasAttribute(\\\"hidden\\\");\\n      },\\n      set hidden(v) {\\n        if (v) {\\n          this.setAttribute(\\\"hidden\\\", \\\"\\\");\\n        } else {\\n          this.removeAttribute(\\\"hidden\\\");\\n        }\\n      }\\n    });\\n    function frag(contextElement, html) {\\n      var p = unwrap(contextElement.cloneNode(false));\\n      p.innerHTML = html;\\n      var df = unwrap(document.createDocumentFragment());\\n      var c;\\n      while (c = p.firstChild) {\\n        df.appendChild(c);\\n      }\\n      return wrap(df);\\n    }\\n    function getter(name) {\\n      return function() {\\n        scope.renderAllPending();\\n        return unsafeUnwrap(this)[name];\\n      };\\n    }\\n    function getterRequiresRendering(name) {\\n      defineGetter(HTMLElement, name, getter(name));\\n    }\\n    [ \\\"clientHeight\\\", \\\"clientLeft\\\", \\\"clientTop\\\", \\\"clientWidth\\\", \\\"offsetHeight\\\", \\\"offsetLeft\\\", \\\"offsetTop\\\", \\\"offsetWidth\\\", \\\"scrollHeight\\\", \\\"scrollWidth\\\" ].forEach(getterRequiresRendering);\\n    function getterAndSetterRequiresRendering(name) {\\n      Object.defineProperty(HTMLElement.prototype, name, {\\n        get: getter(name),\\n        set: function(v) {\\n          scope.renderAllPending();\\n          unsafeUnwrap(this)[name] = v;\\n        },\\n        configurable: true,\\n        enumerable: true\\n      });\\n    }\\n    [ \\\"scrollLeft\\\", \\\"scrollTop\\\" ].forEach(getterAndSetterRequiresRendering);\\n    function methodRequiresRendering(name) {\\n      Object.defineProperty(HTMLElement.prototype, name, {\\n        value: function() {\\n          scope.renderAllPending();\\n          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\\n        },\\n        configurable: true,\\n        enumerable: true\\n      });\\n    }\\n    [ \\\"focus\\\", \\\"getBoundingClientRect\\\", \\\"getClientRects\\\", \\\"scrollIntoView\\\" ].forEach(methodRequiresRendering);\\n    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement(\\\"b\\\"));\\n    scope.wrappers.HTMLElement = HTMLElement;\\n    scope.getInnerHTML = getInnerHTML;\\n    scope.setInnerHTML = setInnerHTML;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrap = scope.wrap;\\n    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\\n    function HTMLCanvasElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLCanvasElement.prototype, {\\n      getContext: function() {\\n        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\\n        return context && wrap(context);\\n      }\\n    });\\n    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement(\\\"canvas\\\"));\\n    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var OriginalHTMLContentElement = window.HTMLContentElement;\\n    function HTMLContentElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLContentElement.prototype, {\\n      constructor: HTMLContentElement,\\n      get select() {\\n        return this.getAttribute(\\\"select\\\");\\n      },\\n      set select(value) {\\n        this.setAttribute(\\\"select\\\", value);\\n      },\\n      setAttribute: function(n, v) {\\n        HTMLElement.prototype.setAttribute.call(this, n, v);\\n        if (String(n).toLowerCase() === \\\"select\\\") this.invalidateShadowRenderer(true);\\n      }\\n    });\\n    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\\n    scope.wrappers.HTMLContentElement = HTMLContentElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\\n    var unwrap = scope.unwrap;\\n    var OriginalHTMLFormElement = window.HTMLFormElement;\\n    function HTMLFormElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLFormElement.prototype, {\\n      get elements() {\\n        return wrapHTMLCollection(unwrap(this).elements);\\n      }\\n    });\\n    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement(\\\"form\\\"));\\n    scope.wrappers.HTMLFormElement = HTMLFormElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var registerWrapper = scope.registerWrapper;\\n    var unwrap = scope.unwrap;\\n    var rewrap = scope.rewrap;\\n    var OriginalHTMLImageElement = window.HTMLImageElement;\\n    function HTMLImageElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\\n    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement(\\\"img\\\"));\\n    function Image(width, height) {\\n      if (!(this instanceof Image)) {\\n        throw new TypeError(\\\"DOM object constructor cannot be called as a function.\\\");\\n      }\\n      var node = unwrap(document.createElement(\\\"img\\\"));\\n      HTMLElement.call(this, node);\\n      rewrap(node, this);\\n      if (width !== undefined) node.width = width;\\n      if (height !== undefined) node.height = height;\\n    }\\n    Image.prototype = HTMLImageElement.prototype;\\n    scope.wrappers.HTMLImageElement = HTMLImageElement;\\n    scope.wrappers.Image = Image;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var NodeList = scope.wrappers.NodeList;\\n    var registerWrapper = scope.registerWrapper;\\n    var OriginalHTMLShadowElement = window.HTMLShadowElement;\\n    function HTMLShadowElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\\n    HTMLShadowElement.prototype.constructor = HTMLShadowElement;\\n    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\\n    scope.wrappers.HTMLShadowElement = HTMLShadowElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var contentTable = new WeakMap();\\n    var templateContentsOwnerTable = new WeakMap();\\n    function getTemplateContentsOwner(doc) {\\n      if (!doc.defaultView) return doc;\\n      var d = templateContentsOwnerTable.get(doc);\\n      if (!d) {\\n        d = doc.implementation.createHTMLDocument(\\\"\\\");\\n        while (d.lastChild) {\\n          d.removeChild(d.lastChild);\\n        }\\n        templateContentsOwnerTable.set(doc, d);\\n      }\\n      return d;\\n    }\\n    function extractContent(templateElement) {\\n      var doc = getTemplateContentsOwner(templateElement.ownerDocument);\\n      var df = unwrap(doc.createDocumentFragment());\\n      var child;\\n      while (child = templateElement.firstChild) {\\n        df.appendChild(child);\\n      }\\n      return df;\\n    }\\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\\n    function HTMLTemplateElement(node) {\\n      HTMLElement.call(this, node);\\n      if (!OriginalHTMLTemplateElement) {\\n        var content = extractContent(node);\\n        contentTable.set(this, wrap(content));\\n      }\\n    }\\n    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLTemplateElement.prototype, {\\n      constructor: HTMLTemplateElement,\\n      get content() {\\n        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);\\n        return contentTable.get(this);\\n      }\\n    });\\n    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\\n    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var registerWrapper = scope.registerWrapper;\\n    var OriginalHTMLMediaElement = window.HTMLMediaElement;\\n    if (!OriginalHTMLMediaElement) return;\\n    function HTMLMediaElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\\n    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement(\\\"audio\\\"));\\n    scope.wrappers.HTMLMediaElement = HTMLMediaElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\\n    var registerWrapper = scope.registerWrapper;\\n    var unwrap = scope.unwrap;\\n    var rewrap = scope.rewrap;\\n    var OriginalHTMLAudioElement = window.HTMLAudioElement;\\n    if (!OriginalHTMLAudioElement) return;\\n    function HTMLAudioElement(node) {\\n      HTMLMediaElement.call(this, node);\\n    }\\n    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\\n    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement(\\\"audio\\\"));\\n    function Audio(src) {\\n      if (!(this instanceof Audio)) {\\n        throw new TypeError(\\\"DOM object constructor cannot be called as a function.\\\");\\n      }\\n      var node = unwrap(document.createElement(\\\"audio\\\"));\\n      HTMLMediaElement.call(this, node);\\n      rewrap(node, this);\\n      node.setAttribute(\\\"preload\\\", \\\"auto\\\");\\n      if (src !== undefined) node.setAttribute(\\\"src\\\", src);\\n    }\\n    Audio.prototype = HTMLAudioElement.prototype;\\n    scope.wrappers.HTMLAudioElement = HTMLAudioElement;\\n    scope.wrappers.Audio = Audio;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var rewrap = scope.rewrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var OriginalHTMLOptionElement = window.HTMLOptionElement;\\n    function trimText(s) {\\n      return s.replace(/\\\\s+/g, \\\" \\\").trim();\\n    }\\n    function HTMLOptionElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLOptionElement.prototype, {\\n      get text() {\\n        return trimText(this.textContent);\\n      },\\n      set text(value) {\\n        this.textContent = trimText(String(value));\\n      },\\n      get form() {\\n        return wrap(unwrap(this).form);\\n      }\\n    });\\n    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement(\\\"option\\\"));\\n    function Option(text, value, defaultSelected, selected) {\\n      if (!(this instanceof Option)) {\\n        throw new TypeError(\\\"DOM object constructor cannot be called as a function.\\\");\\n      }\\n      var node = unwrap(document.createElement(\\\"option\\\"));\\n      HTMLElement.call(this, node);\\n      rewrap(node, this);\\n      if (text !== undefined) node.text = text;\\n      if (value !== undefined) node.setAttribute(\\\"value\\\", value);\\n      if (defaultSelected === true) node.setAttribute(\\\"selected\\\", \\\"\\\");\\n      node.selected = selected === true;\\n    }\\n    Option.prototype = HTMLOptionElement.prototype;\\n    scope.wrappers.HTMLOptionElement = HTMLOptionElement;\\n    scope.wrappers.Option = Option;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var OriginalHTMLSelectElement = window.HTMLSelectElement;\\n    function HTMLSelectElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLSelectElement.prototype, {\\n      add: function(element, before) {\\n        if (typeof before === \\\"object\\\") before = unwrap(before);\\n        unwrap(this).add(unwrap(element), before);\\n      },\\n      remove: function(indexOrNode) {\\n        if (indexOrNode === undefined) {\\n          HTMLElement.prototype.remove.call(this);\\n          return;\\n        }\\n        if (typeof indexOrNode === \\\"object\\\") indexOrNode = unwrap(indexOrNode);\\n        unwrap(this).remove(indexOrNode);\\n      },\\n      get form() {\\n        return wrap(unwrap(this).form);\\n      }\\n    });\\n    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement(\\\"select\\\"));\\n    scope.wrappers.HTMLSelectElement = HTMLSelectElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\\n    var OriginalHTMLTableElement = window.HTMLTableElement;\\n    function HTMLTableElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLTableElement.prototype, {\\n      get caption() {\\n        return wrap(unwrap(this).caption);\\n      },\\n      createCaption: function() {\\n        return wrap(unwrap(this).createCaption());\\n      },\\n      get tHead() {\\n        return wrap(unwrap(this).tHead);\\n      },\\n      createTHead: function() {\\n        return wrap(unwrap(this).createTHead());\\n      },\\n      createTFoot: function() {\\n        return wrap(unwrap(this).createTFoot());\\n      },\\n      get tFoot() {\\n        return wrap(unwrap(this).tFoot);\\n      },\\n      get tBodies() {\\n        return wrapHTMLCollection(unwrap(this).tBodies);\\n      },\\n      createTBody: function() {\\n        return wrap(unwrap(this).createTBody());\\n      },\\n      get rows() {\\n        return wrapHTMLCollection(unwrap(this).rows);\\n      },\\n      insertRow: function(index) {\\n        return wrap(unwrap(this).insertRow(index));\\n      }\\n    });\\n    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement(\\\"table\\\"));\\n    scope.wrappers.HTMLTableElement = HTMLTableElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\\n    function HTMLTableSectionElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLTableSectionElement.prototype, {\\n      constructor: HTMLTableSectionElement,\\n      get rows() {\\n        return wrapHTMLCollection(unwrap(this).rows);\\n      },\\n      insertRow: function(index) {\\n        return wrap(unwrap(this).insertRow(index));\\n      }\\n    });\\n    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement(\\\"thead\\\"));\\n    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\\n    function HTMLTableRowElement(node) {\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\\n    mixin(HTMLTableRowElement.prototype, {\\n      get cells() {\\n        return wrapHTMLCollection(unwrap(this).cells);\\n      },\\n      insertCell: function(index) {\\n        return wrap(unwrap(this).insertCell(index));\\n      }\\n    });\\n    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement(\\\"tr\\\"));\\n    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\\n    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\\n    function HTMLUnknownElement(node) {\\n      switch (node.localName) {\\n       case \\\"content\\\":\\n        return new HTMLContentElement(node);\\n\\n       case \\\"shadow\\\":\\n        return new HTMLShadowElement(node);\\n\\n       case \\\"template\\\":\\n        return new HTMLTemplateElement(node);\\n      }\\n      HTMLElement.call(this, node);\\n    }\\n    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\\n    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\\n    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var Element = scope.wrappers.Element;\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var registerWrapper = scope.registerWrapper;\\n    var defineWrapGetter = scope.defineWrapGetter;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrap = scope.wrap;\\n    var mixin = scope.mixin;\\n    var SVG_NS = \\\"http://www.w3.org/2000/svg\\\";\\n    var OriginalSVGElement = window.SVGElement;\\n    var svgTitleElement = document.createElementNS(SVG_NS, \\\"title\\\");\\n    if (!(\\\"classList\\\" in svgTitleElement)) {\\n      var descr = Object.getOwnPropertyDescriptor(Element.prototype, \\\"classList\\\");\\n      Object.defineProperty(HTMLElement.prototype, \\\"classList\\\", descr);\\n      delete Element.prototype.classList;\\n    }\\n    function SVGElement(node) {\\n      Element.call(this, node);\\n    }\\n    SVGElement.prototype = Object.create(Element.prototype);\\n    mixin(SVGElement.prototype, {\\n      get ownerSVGElement() {\\n        return wrap(unsafeUnwrap(this).ownerSVGElement);\\n      }\\n    });\\n    registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, \\\"title\\\"));\\n    scope.wrappers.SVGElement = SVGElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var OriginalSVGUseElement = window.SVGUseElement;\\n    var SVG_NS = \\\"http://www.w3.org/2000/svg\\\";\\n    var gWrapper = wrap(document.createElementNS(SVG_NS, \\\"g\\\"));\\n    var useElement = document.createElementNS(SVG_NS, \\\"use\\\");\\n    var SVGGElement = gWrapper.constructor;\\n    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\\n    var parentInterface = parentInterfacePrototype.constructor;\\n    function SVGUseElement(impl) {\\n      parentInterface.call(this, impl);\\n    }\\n    SVGUseElement.prototype = Object.create(parentInterfacePrototype);\\n    if (\\\"instanceRoot\\\" in useElement) {\\n      mixin(SVGUseElement.prototype, {\\n        get instanceRoot() {\\n          return wrap(unwrap(this).instanceRoot);\\n        },\\n        get animatedInstanceRoot() {\\n          return wrap(unwrap(this).animatedInstanceRoot);\\n        }\\n      });\\n    }\\n    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\\n    scope.wrappers.SVGUseElement = SVGUseElement;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var EventTarget = scope.wrappers.EventTarget;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var wrap = scope.wrap;\\n    var OriginalSVGElementInstance = window.SVGElementInstance;\\n    if (!OriginalSVGElementInstance) return;\\n    function SVGElementInstance(impl) {\\n      EventTarget.call(this, impl);\\n    }\\n    SVGElementInstance.prototype = Object.create(EventTarget.prototype);\\n    mixin(SVGElementInstance.prototype, {\\n      get correspondingElement() {\\n        return wrap(unsafeUnwrap(this).correspondingElement);\\n      },\\n      get correspondingUseElement() {\\n        return wrap(unsafeUnwrap(this).correspondingUseElement);\\n      },\\n      get parentNode() {\\n        return wrap(unsafeUnwrap(this).parentNode);\\n      },\\n      get childNodes() {\\n        throw new Error(\\\"Not implemented\\\");\\n      },\\n      get firstChild() {\\n        return wrap(unsafeUnwrap(this).firstChild);\\n      },\\n      get lastChild() {\\n        return wrap(unsafeUnwrap(this).lastChild);\\n      },\\n      get previousSibling() {\\n        return wrap(unsafeUnwrap(this).previousSibling);\\n      },\\n      get nextSibling() {\\n        return wrap(unsafeUnwrap(this).nextSibling);\\n      }\\n    });\\n    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\\n    scope.wrappers.SVGElementInstance = SVGElementInstance;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\\n    function CanvasRenderingContext2D(impl) {\\n      setWrapper(impl, this);\\n    }\\n    mixin(CanvasRenderingContext2D.prototype, {\\n      get canvas() {\\n        return wrap(unsafeUnwrap(this).canvas);\\n      },\\n      drawImage: function() {\\n        arguments[0] = unwrapIfNeeded(arguments[0]);\\n        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\\n      },\\n      createPattern: function() {\\n        arguments[0] = unwrap(arguments[0]);\\n        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\\n      }\\n    });\\n    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement(\\\"canvas\\\").getContext(\\\"2d\\\"));\\n    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var addForwardingProperties = scope.addForwardingProperties;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\\n    if (!OriginalWebGLRenderingContext) return;\\n    function WebGLRenderingContext(impl) {\\n      setWrapper(impl, this);\\n    }\\n    mixin(WebGLRenderingContext.prototype, {\\n      get canvas() {\\n        return wrap(unsafeUnwrap(this).canvas);\\n      },\\n      texImage2D: function() {\\n        arguments[5] = unwrapIfNeeded(arguments[5]);\\n        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\\n      },\\n      texSubImage2D: function() {\\n        arguments[6] = unwrapIfNeeded(arguments[6]);\\n        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\\n      }\\n    });\\n    var OriginalWebGLRenderingContextBase = Object.getPrototypeOf(OriginalWebGLRenderingContext.prototype);\\n    if (OriginalWebGLRenderingContextBase !== Object.prototype) {\\n      addForwardingProperties(OriginalWebGLRenderingContextBase, WebGLRenderingContext.prototype);\\n    }\\n    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {\\n      drawingBufferHeight: null,\\n      drawingBufferWidth: null\\n    } : {};\\n    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);\\n    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var Node = scope.wrappers.Node;\\n    var GetElementsByInterface = scope.GetElementsByInterface;\\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\\n    var ParentNodeInterface = scope.ParentNodeInterface;\\n    var SelectorsInterface = scope.SelectorsInterface;\\n    var mixin = scope.mixin;\\n    var registerObject = scope.registerObject;\\n    var registerWrapper = scope.registerWrapper;\\n    var OriginalDocumentFragment = window.DocumentFragment;\\n    function DocumentFragment(node) {\\n      Node.call(this, node);\\n    }\\n    DocumentFragment.prototype = Object.create(Node.prototype);\\n    mixin(DocumentFragment.prototype, ParentNodeInterface);\\n    mixin(DocumentFragment.prototype, SelectorsInterface);\\n    mixin(DocumentFragment.prototype, GetElementsByInterface);\\n    mixin(DocumentFragment.prototype, NonElementParentNodeInterface);\\n    registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());\\n    scope.wrappers.DocumentFragment = DocumentFragment;\\n    var Comment = registerObject(document.createComment(\\\"\\\"));\\n    scope.wrappers.Comment = Comment;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var DocumentFragment = scope.wrappers.DocumentFragment;\\n    var TreeScope = scope.TreeScope;\\n    var elementFromPoint = scope.elementFromPoint;\\n    var getInnerHTML = scope.getInnerHTML;\\n    var getTreeScope = scope.getTreeScope;\\n    var mixin = scope.mixin;\\n    var rewrap = scope.rewrap;\\n    var setInnerHTML = scope.setInnerHTML;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var shadowHostTable = new WeakMap();\\n    var nextOlderShadowTreeTable = new WeakMap();\\n    function ShadowRoot(hostWrapper) {\\n      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\\n      DocumentFragment.call(this, node);\\n      rewrap(node, this);\\n      var oldShadowRoot = hostWrapper.shadowRoot;\\n      nextOlderShadowTreeTable.set(this, oldShadowRoot);\\n      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\\n      shadowHostTable.set(this, hostWrapper);\\n    }\\n    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\\n    mixin(ShadowRoot.prototype, {\\n      constructor: ShadowRoot,\\n      get innerHTML() {\\n        return getInnerHTML(this);\\n      },\\n      set innerHTML(value) {\\n        setInnerHTML(this, value);\\n        this.invalidateShadowRenderer();\\n      },\\n      get olderShadowRoot() {\\n        return nextOlderShadowTreeTable.get(this) || null;\\n      },\\n      get host() {\\n        return shadowHostTable.get(this) || null;\\n      },\\n      invalidateShadowRenderer: function() {\\n        return shadowHostTable.get(this).invalidateShadowRenderer();\\n      },\\n      elementFromPoint: function(x, y) {\\n        return elementFromPoint(this, this.ownerDocument, x, y);\\n      },\\n      getSelection: function() {\\n        return document.getSelection();\\n      },\\n      get activeElement() {\\n        var unwrappedActiveElement = unwrap(this).ownerDocument.activeElement;\\n        if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\\n        var activeElement = wrap(unwrappedActiveElement);\\n        while (!this.contains(activeElement)) {\\n          while (activeElement.parentNode) {\\n            activeElement = activeElement.parentNode;\\n          }\\n          if (activeElement.host) {\\n            activeElement = activeElement.host;\\n          } else {\\n            return null;\\n          }\\n        }\\n        return activeElement;\\n      }\\n    });\\n    scope.wrappers.ShadowRoot = ShadowRoot;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var getTreeScope = scope.getTreeScope;\\n    var OriginalRange = window.Range;\\n    var ShadowRoot = scope.wrappers.ShadowRoot;\\n    function getHost(node) {\\n      var root = getTreeScope(node).root;\\n      if (root instanceof ShadowRoot) {\\n        return root.host;\\n      }\\n      return null;\\n    }\\n    function hostNodeToShadowNode(refNode, offset) {\\n      if (refNode.shadowRoot) {\\n        offset = Math.min(refNode.childNodes.length - 1, offset);\\n        var child = refNode.childNodes[offset];\\n        if (child) {\\n          var insertionPoint = scope.getDestinationInsertionPoints(child);\\n          if (insertionPoint.length > 0) {\\n            var parentNode = insertionPoint[0].parentNode;\\n            if (parentNode.nodeType == Node.ELEMENT_NODE) {\\n              refNode = parentNode;\\n            }\\n          }\\n        }\\n      }\\n      return refNode;\\n    }\\n    function shadowNodeToHostNode(node) {\\n      node = wrap(node);\\n      return getHost(node) || node;\\n    }\\n    function Range(impl) {\\n      setWrapper(impl, this);\\n    }\\n    Range.prototype = {\\n      get startContainer() {\\n        return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);\\n      },\\n      get endContainer() {\\n        return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);\\n      },\\n      get commonAncestorContainer() {\\n        return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);\\n      },\\n      setStart: function(refNode, offset) {\\n        refNode = hostNodeToShadowNode(refNode, offset);\\n        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\\n      },\\n      setEnd: function(refNode, offset) {\\n        refNode = hostNodeToShadowNode(refNode, offset);\\n        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\\n      },\\n      setStartBefore: function(refNode) {\\n        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\\n      },\\n      setStartAfter: function(refNode) {\\n        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\\n      },\\n      setEndBefore: function(refNode) {\\n        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\\n      },\\n      setEndAfter: function(refNode) {\\n        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\\n      },\\n      selectNode: function(refNode) {\\n        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\\n      },\\n      selectNodeContents: function(refNode) {\\n        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\\n      },\\n      compareBoundaryPoints: function(how, sourceRange) {\\n        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\\n      },\\n      extractContents: function() {\\n        return wrap(unsafeUnwrap(this).extractContents());\\n      },\\n      cloneContents: function() {\\n        return wrap(unsafeUnwrap(this).cloneContents());\\n      },\\n      insertNode: function(node) {\\n        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\\n      },\\n      surroundContents: function(newParent) {\\n        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\\n      },\\n      cloneRange: function() {\\n        return wrap(unsafeUnwrap(this).cloneRange());\\n      },\\n      isPointInRange: function(node, offset) {\\n        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\\n      },\\n      comparePoint: function(node, offset) {\\n        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\\n      },\\n      intersectsNode: function(node) {\\n        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\\n      },\\n      toString: function() {\\n        return unsafeUnwrap(this).toString();\\n      }\\n    };\\n    if (OriginalRange.prototype.createContextualFragment) {\\n      Range.prototype.createContextualFragment = function(html) {\\n        return wrap(unsafeUnwrap(this).createContextualFragment(html));\\n      };\\n    }\\n    registerWrapper(window.Range, Range, document.createRange());\\n    scope.wrappers.Range = Range;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var Element = scope.wrappers.Element;\\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\\n    var Node = scope.wrappers.Node;\\n    var ShadowRoot = scope.wrappers.ShadowRoot;\\n    var assert = scope.assert;\\n    var getTreeScope = scope.getTreeScope;\\n    var mixin = scope.mixin;\\n    var oneOf = scope.oneOf;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var ArraySplice = scope.ArraySplice;\\n    function updateWrapperUpAndSideways(wrapper) {\\n      wrapper.previousSibling_ = wrapper.previousSibling;\\n      wrapper.nextSibling_ = wrapper.nextSibling;\\n      wrapper.parentNode_ = wrapper.parentNode;\\n    }\\n    function updateWrapperDown(wrapper) {\\n      wrapper.firstChild_ = wrapper.firstChild;\\n      wrapper.lastChild_ = wrapper.lastChild;\\n    }\\n    function updateAllChildNodes(parentNodeWrapper) {\\n      assert(parentNodeWrapper instanceof Node);\\n      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {\\n        updateWrapperUpAndSideways(childWrapper);\\n      }\\n      updateWrapperDown(parentNodeWrapper);\\n    }\\n    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\\n      var parentNode = unwrap(parentNodeWrapper);\\n      var newChild = unwrap(newChildWrapper);\\n      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\\n      remove(newChildWrapper);\\n      updateWrapperUpAndSideways(newChildWrapper);\\n      if (!refChildWrapper) {\\n        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\\n        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\\n        var lastChildWrapper = wrap(parentNode.lastChild);\\n        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\\n      } else {\\n        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;\\n        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\\n      }\\n      scope.originalInsertBefore.call(parentNode, newChild, refChild);\\n    }\\n    function remove(nodeWrapper) {\\n      var node = unwrap(nodeWrapper);\\n      var parentNode = node.parentNode;\\n      if (!parentNode) return;\\n      var parentNodeWrapper = wrap(parentNode);\\n      updateWrapperUpAndSideways(nodeWrapper);\\n      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\\n      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\\n      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;\\n      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;\\n      scope.originalRemoveChild.call(parentNode, node);\\n    }\\n    var distributedNodesTable = new WeakMap();\\n    var destinationInsertionPointsTable = new WeakMap();\\n    var rendererForHostTable = new WeakMap();\\n    function resetDistributedNodes(insertionPoint) {\\n      distributedNodesTable.set(insertionPoint, []);\\n    }\\n    function getDistributedNodes(insertionPoint) {\\n      var rv = distributedNodesTable.get(insertionPoint);\\n      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);\\n      return rv;\\n    }\\n    function getChildNodesSnapshot(node) {\\n      var result = [], i = 0;\\n      for (var child = node.firstChild; child; child = child.nextSibling) {\\n        result[i++] = child;\\n      }\\n      return result;\\n    }\\n    var request = oneOf(window, [ \\\"requestAnimationFrame\\\", \\\"mozRequestAnimationFrame\\\", \\\"webkitRequestAnimationFrame\\\", \\\"setTimeout\\\" ]);\\n    var pendingDirtyRenderers = [];\\n    var renderTimer;\\n    function renderAllPending() {\\n      for (var i = 0; i < pendingDirtyRenderers.length; i++) {\\n        var renderer = pendingDirtyRenderers[i];\\n        var parentRenderer = renderer.parentRenderer;\\n        if (parentRenderer && parentRenderer.dirty) continue;\\n        renderer.render();\\n      }\\n      pendingDirtyRenderers = [];\\n    }\\n    function handleRequestAnimationFrame() {\\n      renderTimer = null;\\n      renderAllPending();\\n    }\\n    function getRendererForHost(host) {\\n      var renderer = rendererForHostTable.get(host);\\n      if (!renderer) {\\n        renderer = new ShadowRenderer(host);\\n        rendererForHostTable.set(host, renderer);\\n      }\\n      return renderer;\\n    }\\n    function getShadowRootAncestor(node) {\\n      var root = getTreeScope(node).root;\\n      if (root instanceof ShadowRoot) return root;\\n      return null;\\n    }\\n    function getRendererForShadowRoot(shadowRoot) {\\n      return getRendererForHost(shadowRoot.host);\\n    }\\n    var spliceDiff = new ArraySplice();\\n    spliceDiff.equals = function(renderNode, rawNode) {\\n      return unwrap(renderNode.node) === rawNode;\\n    };\\n    function RenderNode(node) {\\n      this.skip = false;\\n      this.node = node;\\n      this.childNodes = [];\\n    }\\n    RenderNode.prototype = {\\n      append: function(node) {\\n        var rv = new RenderNode(node);\\n        this.childNodes.push(rv);\\n        return rv;\\n      },\\n      sync: function(opt_added) {\\n        if (this.skip) return;\\n        var nodeWrapper = this.node;\\n        var newChildren = this.childNodes;\\n        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\\n        var added = opt_added || new WeakMap();\\n        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\\n        var newIndex = 0, oldIndex = 0;\\n        var lastIndex = 0;\\n        for (var i = 0; i < splices.length; i++) {\\n          var splice = splices[i];\\n          for (;lastIndex < splice.index; lastIndex++) {\\n            oldIndex++;\\n            newChildren[newIndex++].sync(added);\\n          }\\n          var removedCount = splice.removed.length;\\n          for (var j = 0; j < removedCount; j++) {\\n            var wrapper = wrap(oldChildren[oldIndex++]);\\n            if (!added.get(wrapper)) remove(wrapper);\\n          }\\n          var addedCount = splice.addedCount;\\n          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\\n          for (var j = 0; j < addedCount; j++) {\\n            var newChildRenderNode = newChildren[newIndex++];\\n            var newChildWrapper = newChildRenderNode.node;\\n            insertBefore(nodeWrapper, newChildWrapper, refNode);\\n            added.set(newChildWrapper, true);\\n            newChildRenderNode.sync(added);\\n          }\\n          lastIndex += addedCount;\\n        }\\n        for (var i = lastIndex; i < newChildren.length; i++) {\\n          newChildren[i].sync(added);\\n        }\\n      }\\n    };\\n    function ShadowRenderer(host) {\\n      this.host = host;\\n      this.dirty = false;\\n      this.invalidateAttributes();\\n      this.associateNode(host);\\n    }\\n    ShadowRenderer.prototype = {\\n      render: function(opt_renderNode) {\\n        if (!this.dirty) return;\\n        this.invalidateAttributes();\\n        var host = this.host;\\n        this.distribution(host);\\n        var renderNode = opt_renderNode || new RenderNode(host);\\n        this.buildRenderTree(renderNode, host);\\n        var topMostRenderer = !opt_renderNode;\\n        if (topMostRenderer) renderNode.sync();\\n        this.dirty = false;\\n      },\\n      get parentRenderer() {\\n        return getTreeScope(this.host).renderer;\\n      },\\n      invalidate: function() {\\n        if (!this.dirty) {\\n          this.dirty = true;\\n          var parentRenderer = this.parentRenderer;\\n          if (parentRenderer) parentRenderer.invalidate();\\n          pendingDirtyRenderers.push(this);\\n          if (renderTimer) return;\\n          renderTimer = window[request](handleRequestAnimationFrame, 0);\\n        }\\n      },\\n      distribution: function(root) {\\n        this.resetAllSubtrees(root);\\n        this.distributionResolution(root);\\n      },\\n      resetAll: function(node) {\\n        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);\\n        this.resetAllSubtrees(node);\\n      },\\n      resetAllSubtrees: function(node) {\\n        for (var child = node.firstChild; child; child = child.nextSibling) {\\n          this.resetAll(child);\\n        }\\n        if (node.shadowRoot) this.resetAll(node.shadowRoot);\\n        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);\\n      },\\n      distributionResolution: function(node) {\\n        if (isShadowHost(node)) {\\n          var shadowHost = node;\\n          var pool = poolPopulation(shadowHost);\\n          var shadowTrees = getShadowTrees(shadowHost);\\n          for (var i = 0; i < shadowTrees.length; i++) {\\n            this.poolDistribution(shadowTrees[i], pool);\\n          }\\n          for (var i = shadowTrees.length - 1; i >= 0; i--) {\\n            var shadowTree = shadowTrees[i];\\n            var shadow = getShadowInsertionPoint(shadowTree);\\n            if (shadow) {\\n              var olderShadowRoot = shadowTree.olderShadowRoot;\\n              if (olderShadowRoot) {\\n                pool = poolPopulation(olderShadowRoot);\\n              }\\n              for (var j = 0; j < pool.length; j++) {\\n                destributeNodeInto(pool[j], shadow);\\n              }\\n            }\\n            this.distributionResolution(shadowTree);\\n          }\\n        }\\n        for (var child = node.firstChild; child; child = child.nextSibling) {\\n          this.distributionResolution(child);\\n        }\\n      },\\n      poolDistribution: function(node, pool) {\\n        if (node instanceof HTMLShadowElement) return;\\n        if (node instanceof HTMLContentElement) {\\n          var content = node;\\n          this.updateDependentAttributes(content.getAttribute(\\\"select\\\"));\\n          var anyDistributed = false;\\n          for (var i = 0; i < pool.length; i++) {\\n            var node = pool[i];\\n            if (!node) continue;\\n            if (matches(node, content)) {\\n              destributeNodeInto(node, content);\\n              pool[i] = undefined;\\n              anyDistributed = true;\\n            }\\n          }\\n          if (!anyDistributed) {\\n            for (var child = content.firstChild; child; child = child.nextSibling) {\\n              destributeNodeInto(child, content);\\n            }\\n          }\\n          return;\\n        }\\n        for (var child = node.firstChild; child; child = child.nextSibling) {\\n          this.poolDistribution(child, pool);\\n        }\\n      },\\n      buildRenderTree: function(renderNode, node) {\\n        var children = this.compose(node);\\n        for (var i = 0; i < children.length; i++) {\\n          var child = children[i];\\n          var childRenderNode = renderNode.append(child);\\n          this.buildRenderTree(childRenderNode, child);\\n        }\\n        if (isShadowHost(node)) {\\n          var renderer = getRendererForHost(node);\\n          renderer.dirty = false;\\n        }\\n      },\\n      compose: function(node) {\\n        var children = [];\\n        var p = node.shadowRoot || node;\\n        for (var child = p.firstChild; child; child = child.nextSibling) {\\n          if (isInsertionPoint(child)) {\\n            this.associateNode(p);\\n            var distributedNodes = getDistributedNodes(child);\\n            for (var j = 0; j < distributedNodes.length; j++) {\\n              var distributedNode = distributedNodes[j];\\n              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);\\n            }\\n          } else {\\n            children.push(child);\\n          }\\n        }\\n        return children;\\n      },\\n      invalidateAttributes: function() {\\n        this.attributes = Object.create(null);\\n      },\\n      updateDependentAttributes: function(selector) {\\n        if (!selector) return;\\n        var attributes = this.attributes;\\n        if (/\\\\.\\\\w+/.test(selector)) attributes[\\\"class\\\"] = true;\\n        if (/#\\\\w+/.test(selector)) attributes[\\\"id\\\"] = true;\\n        selector.replace(/\\\\[\\\\s*([^\\\\s=\\\\|~\\\\]]+)/g, function(_, name) {\\n          attributes[name] = true;\\n        });\\n      },\\n      dependsOnAttribute: function(name) {\\n        return this.attributes[name];\\n      },\\n      associateNode: function(node) {\\n        unsafeUnwrap(node).polymerShadowRenderer_ = this;\\n      }\\n    };\\n    function poolPopulation(node) {\\n      var pool = [];\\n      for (var child = node.firstChild; child; child = child.nextSibling) {\\n        if (isInsertionPoint(child)) {\\n          pool.push.apply(pool, getDistributedNodes(child));\\n        } else {\\n          pool.push(child);\\n        }\\n      }\\n      return pool;\\n    }\\n    function getShadowInsertionPoint(node) {\\n      if (node instanceof HTMLShadowElement) return node;\\n      if (node instanceof HTMLContentElement) return null;\\n      for (var child = node.firstChild; child; child = child.nextSibling) {\\n        var res = getShadowInsertionPoint(child);\\n        if (res) return res;\\n      }\\n      return null;\\n    }\\n    function destributeNodeInto(child, insertionPoint) {\\n      getDistributedNodes(insertionPoint).push(child);\\n      var points = destinationInsertionPointsTable.get(child);\\n      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);\\n    }\\n    function getDestinationInsertionPoints(node) {\\n      return destinationInsertionPointsTable.get(node);\\n    }\\n    function resetDestinationInsertionPoints(node) {\\n      destinationInsertionPointsTable.set(node, undefined);\\n    }\\n    var selectorStartCharRe = /^(:not\\\\()?[*.#[a-zA-Z_|]/;\\n    function matches(node, contentElement) {\\n      var select = contentElement.getAttribute(\\\"select\\\");\\n      if (!select) return true;\\n      select = select.trim();\\n      if (!select) return true;\\n      if (!(node instanceof Element)) return false;\\n      if (!selectorStartCharRe.test(select)) return false;\\n      try {\\n        return node.matches(select);\\n      } catch (ex) {\\n        return false;\\n      }\\n    }\\n    function isFinalDestination(insertionPoint, node) {\\n      var points = getDestinationInsertionPoints(node);\\n      return points && points[points.length - 1] === insertionPoint;\\n    }\\n    function isInsertionPoint(node) {\\n      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;\\n    }\\n    function isShadowHost(shadowHost) {\\n      return shadowHost.shadowRoot;\\n    }\\n    function getShadowTrees(host) {\\n      var trees = [];\\n      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\\n        trees.push(tree);\\n      }\\n      return trees;\\n    }\\n    function render(host) {\\n      new ShadowRenderer(host).render();\\n    }\\n    Node.prototype.invalidateShadowRenderer = function(force) {\\n      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\\n      if (renderer) {\\n        renderer.invalidate();\\n        return true;\\n      }\\n      return false;\\n    };\\n    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {\\n      renderAllPending();\\n      return getDistributedNodes(this);\\n    };\\n    Element.prototype.getDestinationInsertionPoints = function() {\\n      renderAllPending();\\n      return getDestinationInsertionPoints(this) || [];\\n    };\\n    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {\\n      this.invalidateShadowRenderer();\\n      var shadowRoot = getShadowRootAncestor(this);\\n      var renderer;\\n      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);\\n      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\\n      if (renderer) renderer.invalidate();\\n    };\\n    scope.getRendererForHost = getRendererForHost;\\n    scope.getShadowTrees = getShadowTrees;\\n    scope.renderAllPending = renderAllPending;\\n    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\\n    scope.visual = {\\n      insertBefore: insertBefore,\\n      remove: remove\\n    };\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var HTMLElement = scope.wrappers.HTMLElement;\\n    var assert = scope.assert;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var elementsWithFormProperty = [ \\\"HTMLButtonElement\\\", \\\"HTMLFieldSetElement\\\", \\\"HTMLInputElement\\\", \\\"HTMLKeygenElement\\\", \\\"HTMLLabelElement\\\", \\\"HTMLLegendElement\\\", \\\"HTMLObjectElement\\\", \\\"HTMLOutputElement\\\", \\\"HTMLTextAreaElement\\\" ];\\n    function createWrapperConstructor(name) {\\n      if (!window[name]) return;\\n      assert(!scope.wrappers[name]);\\n      var GeneratedWrapper = function(node) {\\n        HTMLElement.call(this, node);\\n      };\\n      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\\n      mixin(GeneratedWrapper.prototype, {\\n        get form() {\\n          return wrap(unwrap(this).form);\\n        }\\n      });\\n      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));\\n      scope.wrappers[name] = GeneratedWrapper;\\n    }\\n    elementsWithFormProperty.forEach(createWrapperConstructor);\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var OriginalSelection = window.Selection;\\n    function Selection(impl) {\\n      setWrapper(impl, this);\\n    }\\n    Selection.prototype = {\\n      get anchorNode() {\\n        return wrap(unsafeUnwrap(this).anchorNode);\\n      },\\n      get focusNode() {\\n        return wrap(unsafeUnwrap(this).focusNode);\\n      },\\n      addRange: function(range) {\\n        unsafeUnwrap(this).addRange(unwrapIfNeeded(range));\\n      },\\n      collapse: function(node, index) {\\n        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\\n      },\\n      containsNode: function(node, allowPartial) {\\n        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\\n      },\\n      getRangeAt: function(index) {\\n        return wrap(unsafeUnwrap(this).getRangeAt(index));\\n      },\\n      removeRange: function(range) {\\n        unsafeUnwrap(this).removeRange(unwrap(range));\\n      },\\n      selectAllChildren: function(node) {\\n        unsafeUnwrap(this).selectAllChildren(node instanceof ShadowRoot ? unsafeUnwrap(node.host) : unwrapIfNeeded(node));\\n      },\\n      toString: function() {\\n        return unsafeUnwrap(this).toString();\\n      }\\n    };\\n    if (OriginalSelection.prototype.extend) {\\n      Selection.prototype.extend = function(node, offset) {\\n        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\\n      };\\n    }\\n    registerWrapper(window.Selection, Selection, window.getSelection());\\n    scope.wrappers.Selection = Selection;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var OriginalTreeWalker = window.TreeWalker;\\n    function TreeWalker(impl) {\\n      setWrapper(impl, this);\\n    }\\n    TreeWalker.prototype = {\\n      get root() {\\n        return wrap(unsafeUnwrap(this).root);\\n      },\\n      get currentNode() {\\n        return wrap(unsafeUnwrap(this).currentNode);\\n      },\\n      set currentNode(node) {\\n        unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);\\n      },\\n      get filter() {\\n        return unsafeUnwrap(this).filter;\\n      },\\n      parentNode: function() {\\n        return wrap(unsafeUnwrap(this).parentNode());\\n      },\\n      firstChild: function() {\\n        return wrap(unsafeUnwrap(this).firstChild());\\n      },\\n      lastChild: function() {\\n        return wrap(unsafeUnwrap(this).lastChild());\\n      },\\n      previousSibling: function() {\\n        return wrap(unsafeUnwrap(this).previousSibling());\\n      },\\n      previousNode: function() {\\n        return wrap(unsafeUnwrap(this).previousNode());\\n      },\\n      nextNode: function() {\\n        return wrap(unsafeUnwrap(this).nextNode());\\n      }\\n    };\\n    registerWrapper(OriginalTreeWalker, TreeWalker);\\n    scope.wrappers.TreeWalker = TreeWalker;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var GetElementsByInterface = scope.GetElementsByInterface;\\n    var Node = scope.wrappers.Node;\\n    var ParentNodeInterface = scope.ParentNodeInterface;\\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\\n    var Selection = scope.wrappers.Selection;\\n    var SelectorsInterface = scope.SelectorsInterface;\\n    var ShadowRoot = scope.wrappers.ShadowRoot;\\n    var TreeScope = scope.TreeScope;\\n    var cloneNode = scope.cloneNode;\\n    var defineGetter = scope.defineGetter;\\n    var defineWrapGetter = scope.defineWrapGetter;\\n    var elementFromPoint = scope.elementFromPoint;\\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\\n    var matchesNames = scope.matchesNames;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var renderAllPending = scope.renderAllPending;\\n    var rewrap = scope.rewrap;\\n    var setWrapper = scope.setWrapper;\\n    var unsafeUnwrap = scope.unsafeUnwrap;\\n    var unwrap = scope.unwrap;\\n    var wrap = scope.wrap;\\n    var wrapEventTargetMethods = scope.wrapEventTargetMethods;\\n    var wrapNodeList = scope.wrapNodeList;\\n    var implementationTable = new WeakMap();\\n    function Document(node) {\\n      Node.call(this, node);\\n      this.treeScope_ = new TreeScope(this, null);\\n    }\\n    Document.prototype = Object.create(Node.prototype);\\n    defineWrapGetter(Document, \\\"documentElement\\\");\\n    defineWrapGetter(Document, \\\"body\\\");\\n    defineWrapGetter(Document, \\\"head\\\");\\n    defineGetter(Document, \\\"activeElement\\\", function() {\\n      var unwrappedActiveElement = unwrap(this).activeElement;\\n      if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\\n      var activeElement = wrap(unwrappedActiveElement);\\n      while (!this.contains(activeElement)) {\\n        while (activeElement.parentNode) {\\n          activeElement = activeElement.parentNode;\\n        }\\n        if (activeElement.host) {\\n          activeElement = activeElement.host;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return activeElement;\\n    });\\n    function wrapMethod(name) {\\n      var original = document[name];\\n      Document.prototype[name] = function() {\\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\\n      };\\n    }\\n    [ \\\"createComment\\\", \\\"createDocumentFragment\\\", \\\"createElement\\\", \\\"createElementNS\\\", \\\"createEvent\\\", \\\"createEventNS\\\", \\\"createRange\\\", \\\"createTextNode\\\" ].forEach(wrapMethod);\\n    var originalAdoptNode = document.adoptNode;\\n    function adoptNodeNoRemove(node, doc) {\\n      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\\n      adoptSubtree(node, doc);\\n    }\\n    function adoptSubtree(node, doc) {\\n      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);\\n      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);\\n      for (var child = node.firstChild; child; child = child.nextSibling) {\\n        adoptSubtree(child, doc);\\n      }\\n    }\\n    function adoptOlderShadowRoots(shadowRoot, doc) {\\n      var oldShadowRoot = shadowRoot.olderShadowRoot;\\n      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);\\n    }\\n    var originalGetSelection = document.getSelection;\\n    mixin(Document.prototype, {\\n      adoptNode: function(node) {\\n        if (node.parentNode) node.parentNode.removeChild(node);\\n        adoptNodeNoRemove(node, this);\\n        return node;\\n      },\\n      elementFromPoint: function(x, y) {\\n        return elementFromPoint(this, this, x, y);\\n      },\\n      importNode: function(node, deep) {\\n        return cloneNode(node, deep, unsafeUnwrap(this));\\n      },\\n      getSelection: function() {\\n        renderAllPending();\\n        return new Selection(originalGetSelection.call(unwrap(this)));\\n      },\\n      getElementsByName: function(name) {\\n        return SelectorsInterface.querySelectorAll.call(this, \\\"[name=\\\" + JSON.stringify(String(name)) + \\\"]\\\");\\n      }\\n    });\\n    var originalCreateTreeWalker = document.createTreeWalker;\\n    var TreeWalkerWrapper = scope.wrappers.TreeWalker;\\n    Document.prototype.createTreeWalker = function(root, whatToShow, filter, expandEntityReferences) {\\n      var newFilter = null;\\n      if (filter) {\\n        if (filter.acceptNode && typeof filter.acceptNode === \\\"function\\\") {\\n          newFilter = {\\n            acceptNode: function(node) {\\n              return filter.acceptNode(wrap(node));\\n            }\\n          };\\n        } else if (typeof filter === \\\"function\\\") {\\n          newFilter = function(node) {\\n            return filter(wrap(node));\\n          };\\n        }\\n      }\\n      return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));\\n    };\\n    if (document.registerElement) {\\n      var originalRegisterElement = document.registerElement;\\n      Document.prototype.registerElement = function(tagName, object) {\\n        var prototype, extendsOption;\\n        if (object !== undefined) {\\n          prototype = object.prototype;\\n          extendsOption = object.extends;\\n        }\\n        if (!prototype) prototype = Object.create(HTMLElement.prototype);\\n        if (scope.nativePrototypeTable.get(prototype)) {\\n          throw new Error(\\\"NotSupportedError\\\");\\n        }\\n        var proto = Object.getPrototypeOf(prototype);\\n        var nativePrototype;\\n        var prototypes = [];\\n        while (proto) {\\n          nativePrototype = scope.nativePrototypeTable.get(proto);\\n          if (nativePrototype) break;\\n          prototypes.push(proto);\\n          proto = Object.getPrototypeOf(proto);\\n        }\\n        if (!nativePrototype) {\\n          throw new Error(\\\"NotSupportedError\\\");\\n        }\\n        var newPrototype = Object.create(nativePrototype);\\n        for (var i = prototypes.length - 1; i >= 0; i--) {\\n          newPrototype = Object.create(newPrototype);\\n        }\\n        [ \\\"createdCallback\\\", \\\"attachedCallback\\\", \\\"detachedCallback\\\", \\\"attributeChangedCallback\\\" ].forEach(function(name) {\\n          var f = prototype[name];\\n          if (!f) return;\\n          newPrototype[name] = function() {\\n            if (!(wrap(this) instanceof CustomElementConstructor)) {\\n              rewrap(this);\\n            }\\n            f.apply(wrap(this), arguments);\\n          };\\n        });\\n        var p = {\\n          prototype: newPrototype\\n        };\\n        if (extendsOption) p.extends = extendsOption;\\n        function CustomElementConstructor(node) {\\n          if (!node) {\\n            if (extendsOption) {\\n              return document.createElement(extendsOption, tagName);\\n            } else {\\n              return document.createElement(tagName);\\n            }\\n          }\\n          setWrapper(node, this);\\n        }\\n        CustomElementConstructor.prototype = prototype;\\n        CustomElementConstructor.prototype.constructor = CustomElementConstructor;\\n        scope.constructorTable.set(newPrototype, CustomElementConstructor);\\n        scope.nativePrototypeTable.set(prototype, newPrototype);\\n        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);\\n        return CustomElementConstructor;\\n      };\\n      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \\\"registerElement\\\" ]);\\n    }\\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ \\\"appendChild\\\", \\\"compareDocumentPosition\\\", \\\"contains\\\", \\\"getElementsByClassName\\\", \\\"getElementsByTagName\\\", \\\"getElementsByTagNameNS\\\", \\\"insertBefore\\\", \\\"querySelector\\\", \\\"querySelectorAll\\\", \\\"removeChild\\\", \\\"replaceChild\\\" ]);\\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);\\n    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \\\"adoptNode\\\", \\\"importNode\\\", \\\"contains\\\", \\\"createComment\\\", \\\"createDocumentFragment\\\", \\\"createElement\\\", \\\"createElementNS\\\", \\\"createEvent\\\", \\\"createEventNS\\\", \\\"createRange\\\", \\\"createTextNode\\\", \\\"createTreeWalker\\\", \\\"elementFromPoint\\\", \\\"getElementById\\\", \\\"getElementsByName\\\", \\\"getSelection\\\" ]);\\n    mixin(Document.prototype, GetElementsByInterface);\\n    mixin(Document.prototype, ParentNodeInterface);\\n    mixin(Document.prototype, SelectorsInterface);\\n    mixin(Document.prototype, NonElementParentNodeInterface);\\n    mixin(Document.prototype, {\\n      get implementation() {\\n        var implementation = implementationTable.get(this);\\n        if (implementation) return implementation;\\n        implementation = new DOMImplementation(unwrap(this).implementation);\\n        implementationTable.set(this, implementation);\\n        return implementation;\\n      },\\n      get defaultView() {\\n        return wrap(unwrap(this).defaultView);\\n      }\\n    });\\n    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(\\\"\\\"));\\n    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);\\n    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);\\n    function DOMImplementation(impl) {\\n      setWrapper(impl, this);\\n    }\\n    var originalCreateDocument = document.implementation.createDocument;\\n    DOMImplementation.prototype.createDocument = function() {\\n      arguments[2] = unwrap(arguments[2]);\\n      return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));\\n    };\\n    function wrapImplMethod(constructor, name) {\\n      var original = document.implementation[name];\\n      constructor.prototype[name] = function() {\\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\\n      };\\n    }\\n    function forwardImplMethod(constructor, name) {\\n      var original = document.implementation[name];\\n      constructor.prototype[name] = function() {\\n        return original.apply(unsafeUnwrap(this), arguments);\\n      };\\n    }\\n    wrapImplMethod(DOMImplementation, \\\"createDocumentType\\\");\\n    wrapImplMethod(DOMImplementation, \\\"createHTMLDocument\\\");\\n    forwardImplMethod(DOMImplementation, \\\"hasFeature\\\");\\n    registerWrapper(window.DOMImplementation, DOMImplementation);\\n    forwardMethodsToWrapper([ window.DOMImplementation ], [ \\\"createDocument\\\", \\\"createDocumentType\\\", \\\"createHTMLDocument\\\", \\\"hasFeature\\\" ]);\\n    scope.adoptNodeNoRemove = adoptNodeNoRemove;\\n    scope.wrappers.DOMImplementation = DOMImplementation;\\n    scope.wrappers.Document = Document;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var EventTarget = scope.wrappers.EventTarget;\\n    var Selection = scope.wrappers.Selection;\\n    var mixin = scope.mixin;\\n    var registerWrapper = scope.registerWrapper;\\n    var renderAllPending = scope.renderAllPending;\\n    var unwrap = scope.unwrap;\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var wrap = scope.wrap;\\n    var OriginalWindow = window.Window;\\n    var originalGetComputedStyle = window.getComputedStyle;\\n    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\\n    var originalGetSelection = window.getSelection;\\n    function Window(impl) {\\n      EventTarget.call(this, impl);\\n    }\\n    Window.prototype = Object.create(EventTarget.prototype);\\n    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\\n      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\\n    };\\n    if (originalGetDefaultComputedStyle) {\\n      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\\n        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);\\n      };\\n    }\\n    OriginalWindow.prototype.getSelection = function() {\\n      return wrap(this || window).getSelection();\\n    };\\n    delete window.getComputedStyle;\\n    delete window.getDefaultComputedStyle;\\n    delete window.getSelection;\\n    [ \\\"addEventListener\\\", \\\"removeEventListener\\\", \\\"dispatchEvent\\\" ].forEach(function(name) {\\n      OriginalWindow.prototype[name] = function() {\\n        var w = wrap(this || window);\\n        return w[name].apply(w, arguments);\\n      };\\n      delete window[name];\\n    });\\n    mixin(Window.prototype, {\\n      getComputedStyle: function(el, pseudo) {\\n        renderAllPending();\\n        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\\n      },\\n      getSelection: function() {\\n        renderAllPending();\\n        return new Selection(originalGetSelection.call(unwrap(this)));\\n      },\\n      get document() {\\n        return wrap(unwrap(this).document);\\n      }\\n    });\\n    if (originalGetDefaultComputedStyle) {\\n      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\\n        renderAllPending();\\n        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\\n      };\\n    }\\n    registerWrapper(OriginalWindow, Window, window);\\n    scope.wrappers.Window = Window;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var unwrap = scope.unwrap;\\n    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\\n    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;\\n    if (OriginalDataTransferSetDragImage) {\\n      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\\n        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\\n      };\\n    }\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var registerWrapper = scope.registerWrapper;\\n    var setWrapper = scope.setWrapper;\\n    var unwrap = scope.unwrap;\\n    var OriginalFormData = window.FormData;\\n    if (!OriginalFormData) return;\\n    function FormData(formElement) {\\n      var impl;\\n      if (formElement instanceof OriginalFormData) {\\n        impl = formElement;\\n      } else {\\n        impl = new OriginalFormData(formElement && unwrap(formElement));\\n      }\\n      setWrapper(impl, this);\\n    }\\n    registerWrapper(OriginalFormData, FormData, new OriginalFormData());\\n    scope.wrappers.FormData = FormData;\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\\n    var originalSend = XMLHttpRequest.prototype.send;\\n    XMLHttpRequest.prototype.send = function(obj) {\\n      return originalSend.call(this, unwrapIfNeeded(obj));\\n    };\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    \\\"use strict\\\";\\n    var isWrapperFor = scope.isWrapperFor;\\n    var elements = {\\n      a: \\\"HTMLAnchorElement\\\",\\n      area: \\\"HTMLAreaElement\\\",\\n      audio: \\\"HTMLAudioElement\\\",\\n      base: \\\"HTMLBaseElement\\\",\\n      body: \\\"HTMLBodyElement\\\",\\n      br: \\\"HTMLBRElement\\\",\\n      button: \\\"HTMLButtonElement\\\",\\n      canvas: \\\"HTMLCanvasElement\\\",\\n      caption: \\\"HTMLTableCaptionElement\\\",\\n      col: \\\"HTMLTableColElement\\\",\\n      content: \\\"HTMLContentElement\\\",\\n      data: \\\"HTMLDataElement\\\",\\n      datalist: \\\"HTMLDataListElement\\\",\\n      del: \\\"HTMLModElement\\\",\\n      dir: \\\"HTMLDirectoryElement\\\",\\n      div: \\\"HTMLDivElement\\\",\\n      dl: \\\"HTMLDListElement\\\",\\n      embed: \\\"HTMLEmbedElement\\\",\\n      fieldset: \\\"HTMLFieldSetElement\\\",\\n      font: \\\"HTMLFontElement\\\",\\n      form: \\\"HTMLFormElement\\\",\\n      frame: \\\"HTMLFrameElement\\\",\\n      frameset: \\\"HTMLFrameSetElement\\\",\\n      h1: \\\"HTMLHeadingElement\\\",\\n      head: \\\"HTMLHeadElement\\\",\\n      hr: \\\"HTMLHRElement\\\",\\n      html: \\\"HTMLHtmlElement\\\",\\n      iframe: \\\"HTMLIFrameElement\\\",\\n      img: \\\"HTMLImageElement\\\",\\n      input: \\\"HTMLInputElement\\\",\\n      keygen: \\\"HTMLKeygenElement\\\",\\n      label: \\\"HTMLLabelElement\\\",\\n      legend: \\\"HTMLLegendElement\\\",\\n      li: \\\"HTMLLIElement\\\",\\n      link: \\\"HTMLLinkElement\\\",\\n      map: \\\"HTMLMapElement\\\",\\n      marquee: \\\"HTMLMarqueeElement\\\",\\n      menu: \\\"HTMLMenuElement\\\",\\n      menuitem: \\\"HTMLMenuItemElement\\\",\\n      meta: \\\"HTMLMetaElement\\\",\\n      meter: \\\"HTMLMeterElement\\\",\\n      object: \\\"HTMLObjectElement\\\",\\n      ol: \\\"HTMLOListElement\\\",\\n      optgroup: \\\"HTMLOptGroupElement\\\",\\n      option: \\\"HTMLOptionElement\\\",\\n      output: \\\"HTMLOutputElement\\\",\\n      p: \\\"HTMLParagraphElement\\\",\\n      param: \\\"HTMLParamElement\\\",\\n      pre: \\\"HTMLPreElement\\\",\\n      progress: \\\"HTMLProgressElement\\\",\\n      q: \\\"HTMLQuoteElement\\\",\\n      script: \\\"HTMLScriptElement\\\",\\n      select: \\\"HTMLSelectElement\\\",\\n      shadow: \\\"HTMLShadowElement\\\",\\n      source: \\\"HTMLSourceElement\\\",\\n      span: \\\"HTMLSpanElement\\\",\\n      style: \\\"HTMLStyleElement\\\",\\n      table: \\\"HTMLTableElement\\\",\\n      tbody: \\\"HTMLTableSectionElement\\\",\\n      template: \\\"HTMLTemplateElement\\\",\\n      textarea: \\\"HTMLTextAreaElement\\\",\\n      thead: \\\"HTMLTableSectionElement\\\",\\n      time: \\\"HTMLTimeElement\\\",\\n      title: \\\"HTMLTitleElement\\\",\\n      tr: \\\"HTMLTableRowElement\\\",\\n      track: \\\"HTMLTrackElement\\\",\\n      ul: \\\"HTMLUListElement\\\",\\n      video: \\\"HTMLVideoElement\\\"\\n    };\\n    function overrideConstructor(tagName) {\\n      var nativeConstructorName = elements[tagName];\\n      var nativeConstructor = window[nativeConstructorName];\\n      if (!nativeConstructor) return;\\n      var element = document.createElement(tagName);\\n      var wrapperConstructor = element.constructor;\\n      window[nativeConstructorName] = wrapperConstructor;\\n    }\\n    Object.keys(elements).forEach(overrideConstructor);\\n    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\\n      window[name] = scope.wrappers[name];\\n    });\\n  })(window.ShadowDOMPolyfill);\\n  (function(scope) {\\n    var ShadowCSS = {\\n      strictStyling: false,\\n      registry: {},\\n      shimStyling: function(root, name, extendsName) {\\n        var scopeStyles = this.prepareRoot(root, name, extendsName);\\n        var typeExtension = this.isTypeExtension(extendsName);\\n        var scopeSelector = this.makeScopeSelector(name, typeExtension);\\n        var cssText = stylesToCssText(scopeStyles, true);\\n        cssText = this.scopeCssText(cssText, scopeSelector);\\n        if (root) {\\n          root.shimmedStyle = cssText;\\n        }\\n        this.addCssToDocument(cssText, name);\\n      },\\n      shimStyle: function(style, selector) {\\n        return this.shimCssText(style.textContent, selector);\\n      },\\n      shimCssText: function(cssText, selector) {\\n        cssText = this.insertDirectives(cssText);\\n        return this.scopeCssText(cssText, selector);\\n      },\\n      makeScopeSelector: function(name, typeExtension) {\\n        if (name) {\\n          return typeExtension ? \\\"[is=\\\" + name + \\\"]\\\" : name;\\n        }\\n        return \\\"\\\";\\n      },\\n      isTypeExtension: function(extendsName) {\\n        return extendsName && extendsName.indexOf(\\\"-\\\") < 0;\\n      },\\n      prepareRoot: function(root, name, extendsName) {\\n        var def = this.registerRoot(root, name, extendsName);\\n        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\\n        this.removeStyles(root, def.rootStyles);\\n        if (this.strictStyling) {\\n          this.applyScopeToContent(root, name);\\n        }\\n        return def.scopeStyles;\\n      },\\n      removeStyles: function(root, styles) {\\n        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\\n          s.parentNode.removeChild(s);\\n        }\\n      },\\n      registerRoot: function(root, name, extendsName) {\\n        var def = this.registry[name] = {\\n          root: root,\\n          name: name,\\n          extendsName: extendsName\\n        };\\n        var styles = this.findStyles(root);\\n        def.rootStyles = styles;\\n        def.scopeStyles = def.rootStyles;\\n        var extendee = this.registry[def.extendsName];\\n        if (extendee) {\\n          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\\n        }\\n        return def;\\n      },\\n      findStyles: function(root) {\\n        if (!root) {\\n          return [];\\n        }\\n        var styles = root.querySelectorAll(\\\"style\\\");\\n        return Array.prototype.filter.call(styles, function(s) {\\n          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\\n        });\\n      },\\n      applyScopeToContent: function(root, name) {\\n        if (root) {\\n          Array.prototype.forEach.call(root.querySelectorAll(\\\"*\\\"), function(node) {\\n            node.setAttribute(name, \\\"\\\");\\n          });\\n          Array.prototype.forEach.call(root.querySelectorAll(\\\"template\\\"), function(template) {\\n            this.applyScopeToContent(template.content, name);\\n          }, this);\\n        }\\n      },\\n      insertDirectives: function(cssText) {\\n        cssText = this.insertPolyfillDirectivesInCssText(cssText);\\n        return this.insertPolyfillRulesInCssText(cssText);\\n      },\\n      insertPolyfillDirectivesInCssText: function(cssText) {\\n        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\\n          return p1.slice(0, -2) + \\\"{\\\";\\n        });\\n        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\\n          return p1 + \\\" {\\\";\\n        });\\n      },\\n      insertPolyfillRulesInCssText: function(cssText) {\\n        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\\n          return p1.slice(0, -1);\\n        });\\n        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\\n          var rule = match.replace(p1, \\\"\\\").replace(p2, \\\"\\\");\\n          return p3 + rule;\\n        });\\n      },\\n      scopeCssText: function(cssText, scopeSelector) {\\n        var unscoped = this.extractUnscopedRulesFromCssText(cssText);\\n        cssText = this.insertPolyfillHostInCssText(cssText);\\n        cssText = this.convertColonHost(cssText);\\n        cssText = this.convertColonHostContext(cssText);\\n        cssText = this.convertShadowDOMSelectors(cssText);\\n        if (scopeSelector) {\\n          var self = this, cssText;\\n          withCssRules(cssText, function(rules) {\\n            cssText = self.scopeRules(rules, scopeSelector);\\n          });\\n        }\\n        cssText = cssText + \\\"\\\\n\\\" + unscoped;\\n        return cssText.trim();\\n      },\\n      extractUnscopedRulesFromCssText: function(cssText) {\\n        var r = \\\"\\\", m;\\n        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\\n          r += m[1].slice(0, -1) + \\\"\\\\n\\\\n\\\";\\n        }\\n        while (m = cssContentUnscopedRuleRe.exec(cssText)) {\\n          r += m[0].replace(m[2], \\\"\\\").replace(m[1], m[3]) + \\\"\\\\n\\\\n\\\";\\n        }\\n        return r;\\n      },\\n      convertColonHost: function(cssText) {\\n        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);\\n      },\\n      convertColonHostContext: function(cssText) {\\n        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);\\n      },\\n      convertColonRule: function(cssText, regExp, partReplacer) {\\n        return cssText.replace(regExp, function(m, p1, p2, p3) {\\n          p1 = polyfillHostNoCombinator;\\n          if (p2) {\\n            var parts = p2.split(\\\",\\\"), r = [];\\n            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\\n              p = p.trim();\\n              r.push(partReplacer(p1, p, p3));\\n            }\\n            return r.join(\\\",\\\");\\n          } else {\\n            return p1 + p3;\\n          }\\n        });\\n      },\\n      colonHostContextPartReplacer: function(host, part, suffix) {\\n        if (part.match(polyfillHost)) {\\n          return this.colonHostPartReplacer(host, part, suffix);\\n        } else {\\n          return host + part + suffix + \\\", \\\" + part + \\\" \\\" + host + suffix;\\n        }\\n      },\\n      colonHostPartReplacer: function(host, part, suffix) {\\n        return host + part.replace(polyfillHost, \\\"\\\") + suffix;\\n      },\\n      convertShadowDOMSelectors: function(cssText) {\\n        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {\\n          cssText = cssText.replace(shadowDOMSelectorsRe[i], \\\" \\\");\\n        }\\n        return cssText;\\n      },\\n      scopeRules: function(cssRules, scopeSelector) {\\n        var cssText = \\\"\\\";\\n        if (cssRules) {\\n          Array.prototype.forEach.call(cssRules, function(rule) {\\n            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\\n              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + \\\" {\\\\n\\\\t\\\";\\n              cssText += this.propertiesFromRule(rule) + \\\"\\\\n}\\\\n\\\\n\\\";\\n            } else if (rule.type === CSSRule.MEDIA_RULE) {\\n              cssText += \\\"@media \\\" + rule.media.mediaText + \\\" {\\\\n\\\";\\n              cssText += this.scopeRules(rule.cssRules, scopeSelector);\\n              cssText += \\\"\\\\n}\\\\n\\\\n\\\";\\n            } else {\\n              try {\\n                if (rule.cssText) {\\n                  cssText += rule.cssText + \\\"\\\\n\\\\n\\\";\\n                }\\n              } catch (x) {\\n                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\\n                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\\n                }\\n              }\\n            }\\n          }, this);\\n        }\\n        return cssText;\\n      },\\n      ieSafeCssTextFromKeyFrameRule: function(rule) {\\n        var cssText = \\\"@keyframes \\\" + rule.name + \\\" {\\\";\\n        Array.prototype.forEach.call(rule.cssRules, function(rule) {\\n          cssText += \\\" \\\" + rule.keyText + \\\" {\\\" + rule.style.cssText + \\\"}\\\";\\n        });\\n        cssText += \\\" }\\\";\\n        return cssText;\\n      },\\n      scopeSelector: function(selector, scopeSelector, strict) {\\n        var r = [], parts = selector.split(\\\",\\\");\\n        parts.forEach(function(p) {\\n          p = p.trim();\\n          if (this.selectorNeedsScoping(p, scopeSelector)) {\\n            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);\\n          }\\n          r.push(p);\\n        }, this);\\n        return r.join(\\\", \\\");\\n      },\\n      selectorNeedsScoping: function(selector, scopeSelector) {\\n        if (Array.isArray(scopeSelector)) {\\n          return true;\\n        }\\n        var re = this.makeScopeMatcher(scopeSelector);\\n        return !selector.match(re);\\n      },\\n      makeScopeMatcher: function(scopeSelector) {\\n        scopeSelector = scopeSelector.replace(/\\\\[/g, \\\"\\\\\\\\[\\\").replace(/\\\\]/g, \\\"\\\\\\\\]\\\");\\n        return new RegExp(\\\"^(\\\" + scopeSelector + \\\")\\\" + selectorReSuffix, \\\"m\\\");\\n      },\\n      applySelectorScope: function(selector, selectorScope) {\\n        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);\\n      },\\n      applySelectorScopeList: function(selector, scopeSelectorList) {\\n        var r = [];\\n        for (var i = 0, s; s = scopeSelectorList[i]; i++) {\\n          r.push(this.applySimpleSelectorScope(selector, s));\\n        }\\n        return r.join(\\\", \\\");\\n      },\\n      applySimpleSelectorScope: function(selector, scopeSelector) {\\n        if (selector.match(polyfillHostRe)) {\\n          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\\n          return selector.replace(polyfillHostRe, scopeSelector + \\\" \\\");\\n        } else {\\n          return scopeSelector + \\\" \\\" + selector;\\n        }\\n      },\\n      applyStrictSelectorScope: function(selector, scopeSelector) {\\n        scopeSelector = scopeSelector.replace(/\\\\[is=([^\\\\]]*)\\\\]/g, \\\"$1\\\");\\n        var splits = [ \\\" \\\", \\\">\\\", \\\"+\\\", \\\"~\\\" ], scoped = selector, attrName = \\\"[\\\" + scopeSelector + \\\"]\\\";\\n        splits.forEach(function(sep) {\\n          var parts = scoped.split(sep);\\n          scoped = parts.map(function(p) {\\n            var t = p.trim().replace(polyfillHostRe, \\\"\\\");\\n            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {\\n              p = t.replace(/([^:]*)(:*)(.*)/, \\\"$1\\\" + attrName + \\\"$2$3\\\");\\n            }\\n            return p;\\n          }).join(sep);\\n        });\\n        return scoped;\\n      },\\n      insertPolyfillHostInCssText: function(selector) {\\n        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);\\n      },\\n      propertiesFromRule: function(rule) {\\n        var cssText = rule.style.cssText;\\n        if (rule.style.content && !rule.style.content.match(/['\\\"]+|attr/)) {\\n          cssText = cssText.replace(/content:[^;]*;/g, \\\"content: '\\\" + rule.style.content + \\\"';\\\");\\n        }\\n        var style = rule.style;\\n        for (var i in style) {\\n          if (style[i] === \\\"initial\\\") {\\n            cssText += i + \\\": initial; \\\";\\n          }\\n        }\\n        return cssText;\\n      },\\n      replaceTextInStyles: function(styles, action) {\\n        if (styles && action) {\\n          if (!(styles instanceof Array)) {\\n            styles = [ styles ];\\n          }\\n          Array.prototype.forEach.call(styles, function(s) {\\n            s.textContent = action.call(this, s.textContent);\\n          }, this);\\n        }\\n      },\\n      addCssToDocument: function(cssText, name) {\\n        if (cssText.match(\\\"@import\\\")) {\\n          addOwnSheet(cssText, name);\\n        } else {\\n          addCssToDocument(cssText);\\n        }\\n      }\\n    };\\n    var selectorRe = /([^{]*)({[\\\\s\\\\S]*?})/gim, cssCommentRe = /\\\\/\\\\*[^*]*\\\\*+([^\\\\/*][^*]*\\\\*+)*\\\\//gim, cssCommentNextSelectorRe = /\\\\/\\\\*\\\\s*@polyfill ([^*]*\\\\*+([^\\\\/*][^*]*\\\\*+)*\\\\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\\\:[\\\\s]*?['\\\"](.*?)['\\\"][;\\\\s]*}([^{]*?){/gim, cssCommentRuleRe = /\\\\/\\\\*\\\\s@polyfill-rule([^*]*\\\\*+([^\\\\/*][^*]*\\\\*+)*)\\\\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\\\\:[\\\\s]*['\\\"](.*?)['\\\"])[;\\\\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\\\\/\\\\*\\\\s@polyfill-unscoped-rule([^*]*\\\\*+([^\\\\/*][^*]*\\\\*+)*)\\\\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\\\:[\\\\s]*['\\\"](.*?)['\\\"])[;\\\\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\\\\s{,(]*)/gim, cssPartRe = /::part\\\\(([^)]*)\\\\)/gim, polyfillHost = \\\"-shadowcsshost\\\", polyfillHostContext = \\\"-shadowcsscontext\\\", parenSuffix = \\\")(?:\\\\\\\\((\\\" + \\\"(?:\\\\\\\\([^)(]*\\\\\\\\)|[^)(]*)+?\\\" + \\\")\\\\\\\\))?([^,{]*)\\\";\\n    var cssColonHostRe = new RegExp(\\\"(\\\" + polyfillHost + parenSuffix, \\\"gim\\\"), cssColonHostContextRe = new RegExp(\\\"(\\\" + polyfillHostContext + parenSuffix, \\\"gim\\\"), selectorReSuffix = \\\"([>\\\\\\\\s~+[.,{:][\\\\\\\\s\\\\\\\\S]*)?$\\\", colonHostRe = /\\\\:host/gim, colonHostContextRe = /\\\\:host-context/gim, polyfillHostNoCombinator = polyfillHost + \\\"-no-combinator\\\", polyfillHostRe = new RegExp(polyfillHost, \\\"gim\\\"), polyfillHostContextRe = new RegExp(polyfillHostContext, \\\"gim\\\"), shadowDOMSelectorsRe = [ />>>/g, /::shadow/g, /::content/g, /\\\\/deep\\\\//g, /\\\\/shadow\\\\//g, /\\\\/shadow-deep\\\\//g, /\\\\^\\\\^/g, /\\\\^(?!=)/g ];\\n    function stylesToCssText(styles, preserveComments) {\\n      var cssText = \\\"\\\";\\n      Array.prototype.forEach.call(styles, function(s) {\\n        cssText += s.textContent + \\\"\\\\n\\\\n\\\";\\n      });\\n      if (!preserveComments) {\\n        cssText = cssText.replace(cssCommentRe, \\\"\\\");\\n      }\\n      return cssText;\\n    }\\n    function cssTextToStyle(cssText) {\\n      var style = document.createElement(\\\"style\\\");\\n      style.textContent = cssText;\\n      return style;\\n    }\\n    function cssToRules(cssText) {\\n      var style = cssTextToStyle(cssText);\\n      document.head.appendChild(style);\\n      var rules = [];\\n      if (style.sheet) {\\n        try {\\n          rules = style.sheet.cssRules;\\n        } catch (e) {}\\n      } else {\\n        console.warn(\\\"sheet not found\\\", style);\\n      }\\n      style.parentNode.removeChild(style);\\n      return rules;\\n    }\\n    var frame = document.createElement(\\\"iframe\\\");\\n    frame.style.display = \\\"none\\\";\\n    function initFrame() {\\n      frame.initialized = true;\\n      document.body.appendChild(frame);\\n      var doc = frame.contentDocument;\\n      var base = doc.createElement(\\\"base\\\");\\n      base.href = document.baseURI;\\n      doc.head.appendChild(base);\\n    }\\n    function inFrame(fn) {\\n      if (!frame.initialized) {\\n        initFrame();\\n      }\\n      document.body.appendChild(frame);\\n      fn(frame.contentDocument);\\n      document.body.removeChild(frame);\\n    }\\n    var isChrome = navigator.userAgent.match(\\\"Chrome\\\");\\n    function withCssRules(cssText, callback) {\\n      if (!callback) {\\n        return;\\n      }\\n      var rules;\\n      if (cssText.match(\\\"@import\\\") && isChrome) {\\n        var style = cssTextToStyle(cssText);\\n        inFrame(function(doc) {\\n          doc.head.appendChild(style.impl);\\n          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\\n          callback(rules);\\n        });\\n      } else {\\n        rules = cssToRules(cssText);\\n        callback(rules);\\n      }\\n    }\\n    function rulesToCss(cssRules) {\\n      for (var i = 0, css = []; i < cssRules.length; i++) {\\n        css.push(cssRules[i].cssText);\\n      }\\n      return css.join(\\\"\\\\n\\\\n\\\");\\n    }\\n    function addCssToDocument(cssText) {\\n      if (cssText) {\\n        getSheet().appendChild(document.createTextNode(cssText));\\n      }\\n    }\\n    function addOwnSheet(cssText, name) {\\n      var style = cssTextToStyle(cssText);\\n      style.setAttribute(name, \\\"\\\");\\n      style.setAttribute(SHIMMED_ATTRIBUTE, \\\"\\\");\\n      document.head.appendChild(style);\\n    }\\n    var SHIM_ATTRIBUTE = \\\"shim-shadowdom\\\";\\n    var SHIMMED_ATTRIBUTE = \\\"shim-shadowdom-css\\\";\\n    var NO_SHIM_ATTRIBUTE = \\\"no-shim\\\";\\n    var sheet;\\n    function getSheet() {\\n      if (!sheet) {\\n        sheet = document.createElement(\\\"style\\\");\\n        sheet.setAttribute(SHIMMED_ATTRIBUTE, \\\"\\\");\\n        sheet[SHIMMED_ATTRIBUTE] = true;\\n      }\\n      return sheet;\\n    }\\n    if (window.ShadowDOMPolyfill) {\\n      addCssToDocument(\\\"style { display: none !important; }\\\\n\\\");\\n      var doc = ShadowDOMPolyfill.wrap(document);\\n      var head = doc.querySelector(\\\"head\\\");\\n      head.insertBefore(getSheet(), head.childNodes[0]);\\n      document.addEventListener(\\\"DOMContentLoaded\\\", function() {\\n        var urlResolver = scope.urlResolver;\\n        if (window.HTMLImports && !HTMLImports.useNative) {\\n          var SHIM_SHEET_SELECTOR = \\\"link[rel=stylesheet]\\\" + \\\"[\\\" + SHIM_ATTRIBUTE + \\\"]\\\";\\n          var SHIM_STYLE_SELECTOR = \\\"style[\\\" + SHIM_ATTRIBUTE + \\\"]\\\";\\n          HTMLImports.importer.documentPreloadSelectors += \\\",\\\" + SHIM_SHEET_SELECTOR;\\n          HTMLImports.importer.importsPreloadSelectors += \\\",\\\" + SHIM_SHEET_SELECTOR;\\n          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(\\\",\\\");\\n          var originalParseGeneric = HTMLImports.parser.parseGeneric;\\n          HTMLImports.parser.parseGeneric = function(elt) {\\n            if (elt[SHIMMED_ATTRIBUTE]) {\\n              return;\\n            }\\n            var style = elt.__importElement || elt;\\n            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\\n              originalParseGeneric.call(this, elt);\\n              return;\\n            }\\n            if (elt.__resource) {\\n              style = elt.ownerDocument.createElement(\\\"style\\\");\\n              style.textContent = elt.__resource;\\n            }\\n            HTMLImports.path.resolveUrlsInStyle(style, elt.href);\\n            style.textContent = ShadowCSS.shimStyle(style);\\n            style.removeAttribute(SHIM_ATTRIBUTE, \\\"\\\");\\n            style.setAttribute(SHIMMED_ATTRIBUTE, \\\"\\\");\\n            style[SHIMMED_ATTRIBUTE] = true;\\n            if (style.parentNode !== head) {\\n              if (elt.parentNode === head) {\\n                head.replaceChild(style, elt);\\n              } else {\\n                this.addElementToDocument(style);\\n              }\\n            }\\n            style.__importParsed = true;\\n            this.markParsingComplete(elt);\\n            this.parseNext();\\n          };\\n          var hasResource = HTMLImports.parser.hasResource;\\n          HTMLImports.parser.hasResource = function(node) {\\n            if (node.localName === \\\"link\\\" && node.rel === \\\"stylesheet\\\" && node.hasAttribute(SHIM_ATTRIBUTE)) {\\n              return node.__resource;\\n            } else {\\n              return hasResource.call(this, node);\\n            }\\n          };\\n        }\\n      });\\n    }\\n    scope.ShadowCSS = ShadowCSS;\\n  })(window.WebComponents);\\n}\\n\\n(function(scope) {\\n  if (window.ShadowDOMPolyfill) {\\n    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\\n    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\\n  } else {\\n    window.wrap = window.unwrap = function(n) {\\n      return n;\\n    };\\n  }\\n})(window.WebComponents);\\n\\n(function(scope) {\\n  \\\"use strict\\\";\\n  var hasWorkingUrl = false;\\n  if (!scope.forceJURL) {\\n    try {\\n      var u = new URL(\\\"b\\\", \\\"http://a\\\");\\n      u.pathname = \\\"c%20d\\\";\\n      hasWorkingUrl = u.href === \\\"http://a/c%20d\\\";\\n    } catch (e) {}\\n  }\\n  if (hasWorkingUrl) return;\\n  var relative = Object.create(null);\\n  relative[\\\"ftp\\\"] = 21;\\n  relative[\\\"file\\\"] = 0;\\n  relative[\\\"gopher\\\"] = 70;\\n  relative[\\\"http\\\"] = 80;\\n  relative[\\\"https\\\"] = 443;\\n  relative[\\\"ws\\\"] = 80;\\n  relative[\\\"wss\\\"] = 443;\\n  var relativePathDotMapping = Object.create(null);\\n  relativePathDotMapping[\\\"%2e\\\"] = \\\".\\\";\\n  relativePathDotMapping[\\\".%2e\\\"] = \\\"..\\\";\\n  relativePathDotMapping[\\\"%2e.\\\"] = \\\"..\\\";\\n  relativePathDotMapping[\\\"%2e%2e\\\"] = \\\"..\\\";\\n  function isRelativeScheme(scheme) {\\n    return relative[scheme] !== undefined;\\n  }\\n  function invalid() {\\n    clear.call(this);\\n    this._isInvalid = true;\\n  }\\n  function IDNAToASCII(h) {\\n    if (\\\"\\\" == h) {\\n      invalid.call(this);\\n    }\\n    return h.toLowerCase();\\n  }\\n  function percentEscape(c) {\\n    var unicode = c.charCodeAt(0);\\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\\n      return c;\\n    }\\n    return encodeURIComponent(c);\\n  }\\n  function percentEscapeQuery(c) {\\n    var unicode = c.charCodeAt(0);\\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\\n      return c;\\n    }\\n    return encodeURIComponent(c);\\n  }\\n  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\\\+\\\\-\\\\.]/;\\n  function parse(input, stateOverride, base) {\\n    function err(message) {\\n      errors.push(message);\\n    }\\n    var state = stateOverride || \\\"scheme start\\\", cursor = 0, buffer = \\\"\\\", seenAt = false, seenBracket = false, errors = [];\\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\\n      var c = input[cursor];\\n      switch (state) {\\n       case \\\"scheme start\\\":\\n        if (c && ALPHA.test(c)) {\\n          buffer += c.toLowerCase();\\n          state = \\\"scheme\\\";\\n        } else if (!stateOverride) {\\n          buffer = \\\"\\\";\\n          state = \\\"no scheme\\\";\\n          continue;\\n        } else {\\n          err(\\\"Invalid scheme.\\\");\\n          break loop;\\n        }\\n        break;\\n\\n       case \\\"scheme\\\":\\n        if (c && ALPHANUMERIC.test(c)) {\\n          buffer += c.toLowerCase();\\n        } else if (\\\":\\\" == c) {\\n          this._scheme = buffer;\\n          buffer = \\\"\\\";\\n          if (stateOverride) {\\n            break loop;\\n          }\\n          if (isRelativeScheme(this._scheme)) {\\n            this._isRelative = true;\\n          }\\n          if (\\\"file\\\" == this._scheme) {\\n            state = \\\"relative\\\";\\n          } else if (this._isRelative && base && base._scheme == this._scheme) {\\n            state = \\\"relative or authority\\\";\\n          } else if (this._isRelative) {\\n            state = \\\"authority first slash\\\";\\n          } else {\\n            state = \\\"scheme data\\\";\\n          }\\n        } else if (!stateOverride) {\\n          buffer = \\\"\\\";\\n          cursor = 0;\\n          state = \\\"no scheme\\\";\\n          continue;\\n        } else if (EOF == c) {\\n          break loop;\\n        } else {\\n          err(\\\"Code point not allowed in scheme: \\\" + c);\\n          break loop;\\n        }\\n        break;\\n\\n       case \\\"scheme data\\\":\\n        if (\\\"?\\\" == c) {\\n          this._query = \\\"?\\\";\\n          state = \\\"query\\\";\\n        } else if (\\\"#\\\" == c) {\\n          this._fragment = \\\"#\\\";\\n          state = \\\"fragment\\\";\\n        } else {\\n          if (EOF != c && \\\"\\\\t\\\" != c && \\\"\\\\n\\\" != c && \\\"\\\\r\\\" != c) {\\n            this._schemeData += percentEscape(c);\\n          }\\n        }\\n        break;\\n\\n       case \\\"no scheme\\\":\\n        if (!base || !isRelativeScheme(base._scheme)) {\\n          err(\\\"Missing scheme.\\\");\\n          invalid.call(this);\\n        } else {\\n          state = \\\"relative\\\";\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"relative or authority\\\":\\n        if (\\\"/\\\" == c && \\\"/\\\" == input[cursor + 1]) {\\n          state = \\\"authority ignore slashes\\\";\\n        } else {\\n          err(\\\"Expected /, got: \\\" + c);\\n          state = \\\"relative\\\";\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"relative\\\":\\n        this._isRelative = true;\\n        if (\\\"file\\\" != this._scheme) this._scheme = base._scheme;\\n        if (EOF == c) {\\n          this._host = base._host;\\n          this._port = base._port;\\n          this._path = base._path.slice();\\n          this._query = base._query;\\n          this._username = base._username;\\n          this._password = base._password;\\n          break loop;\\n        } else if (\\\"/\\\" == c || \\\"\\\\\\\\\\\" == c) {\\n          if (\\\"\\\\\\\\\\\" == c) err(\\\"\\\\\\\\ is an invalid code point.\\\");\\n          state = \\\"relative slash\\\";\\n        } else if (\\\"?\\\" == c) {\\n          this._host = base._host;\\n          this._port = base._port;\\n          this._path = base._path.slice();\\n          this._query = \\\"?\\\";\\n          this._username = base._username;\\n          this._password = base._password;\\n          state = \\\"query\\\";\\n        } else if (\\\"#\\\" == c) {\\n          this._host = base._host;\\n          this._port = base._port;\\n          this._path = base._path.slice();\\n          this._query = base._query;\\n          this._fragment = \\\"#\\\";\\n          this._username = base._username;\\n          this._password = base._password;\\n          state = \\\"fragment\\\";\\n        } else {\\n          var nextC = input[cursor + 1];\\n          var nextNextC = input[cursor + 2];\\n          if (\\\"file\\\" != this._scheme || !ALPHA.test(c) || nextC != \\\":\\\" && nextC != \\\"|\\\" || EOF != nextNextC && \\\"/\\\" != nextNextC && \\\"\\\\\\\\\\\" != nextNextC && \\\"?\\\" != nextNextC && \\\"#\\\" != nextNextC) {\\n            this._host = base._host;\\n            this._port = base._port;\\n            this._username = base._username;\\n            this._password = base._password;\\n            this._path = base._path.slice();\\n            this._path.pop();\\n          }\\n          state = \\\"relative path\\\";\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"relative slash\\\":\\n        if (\\\"/\\\" == c || \\\"\\\\\\\\\\\" == c) {\\n          if (\\\"\\\\\\\\\\\" == c) {\\n            err(\\\"\\\\\\\\ is an invalid code point.\\\");\\n          }\\n          if (\\\"file\\\" == this._scheme) {\\n            state = \\\"file host\\\";\\n          } else {\\n            state = \\\"authority ignore slashes\\\";\\n          }\\n        } else {\\n          if (\\\"file\\\" != this._scheme) {\\n            this._host = base._host;\\n            this._port = base._port;\\n            this._username = base._username;\\n            this._password = base._password;\\n          }\\n          state = \\\"relative path\\\";\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"authority first slash\\\":\\n        if (\\\"/\\\" == c) {\\n          state = \\\"authority second slash\\\";\\n        } else {\\n          err(\\\"Expected '/', got: \\\" + c);\\n          state = \\\"authority ignore slashes\\\";\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"authority second slash\\\":\\n        state = \\\"authority ignore slashes\\\";\\n        if (\\\"/\\\" != c) {\\n          err(\\\"Expected '/', got: \\\" + c);\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"authority ignore slashes\\\":\\n        if (\\\"/\\\" != c && \\\"\\\\\\\\\\\" != c) {\\n          state = \\\"authority\\\";\\n          continue;\\n        } else {\\n          err(\\\"Expected authority, got: \\\" + c);\\n        }\\n        break;\\n\\n       case \\\"authority\\\":\\n        if (\\\"@\\\" == c) {\\n          if (seenAt) {\\n            err(\\\"@ already seen.\\\");\\n            buffer += \\\"%40\\\";\\n          }\\n          seenAt = true;\\n          for (var i = 0; i < buffer.length; i++) {\\n            var cp = buffer[i];\\n            if (\\\"\\\\t\\\" == cp || \\\"\\\\n\\\" == cp || \\\"\\\\r\\\" == cp) {\\n              err(\\\"Invalid whitespace in authority.\\\");\\n              continue;\\n            }\\n            if (\\\":\\\" == cp && null === this._password) {\\n              this._password = \\\"\\\";\\n              continue;\\n            }\\n            var tempC = percentEscape(cp);\\n            null !== this._password ? this._password += tempC : this._username += tempC;\\n          }\\n          buffer = \\\"\\\";\\n        } else if (EOF == c || \\\"/\\\" == c || \\\"\\\\\\\\\\\" == c || \\\"?\\\" == c || \\\"#\\\" == c) {\\n          cursor -= buffer.length;\\n          buffer = \\\"\\\";\\n          state = \\\"host\\\";\\n          continue;\\n        } else {\\n          buffer += c;\\n        }\\n        break;\\n\\n       case \\\"file host\\\":\\n        if (EOF == c || \\\"/\\\" == c || \\\"\\\\\\\\\\\" == c || \\\"?\\\" == c || \\\"#\\\" == c) {\\n          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == \\\":\\\" || buffer[1] == \\\"|\\\")) {\\n            state = \\\"relative path\\\";\\n          } else if (buffer.length == 0) {\\n            state = \\\"relative path start\\\";\\n          } else {\\n            this._host = IDNAToASCII.call(this, buffer);\\n            buffer = \\\"\\\";\\n            state = \\\"relative path start\\\";\\n          }\\n          continue;\\n        } else if (\\\"\\\\t\\\" == c || \\\"\\\\n\\\" == c || \\\"\\\\r\\\" == c) {\\n          err(\\\"Invalid whitespace in file host.\\\");\\n        } else {\\n          buffer += c;\\n        }\\n        break;\\n\\n       case \\\"host\\\":\\n       case \\\"hostname\\\":\\n        if (\\\":\\\" == c && !seenBracket) {\\n          this._host = IDNAToASCII.call(this, buffer);\\n          buffer = \\\"\\\";\\n          state = \\\"port\\\";\\n          if (\\\"hostname\\\" == stateOverride) {\\n            break loop;\\n          }\\n        } else if (EOF == c || \\\"/\\\" == c || \\\"\\\\\\\\\\\" == c || \\\"?\\\" == c || \\\"#\\\" == c) {\\n          this._host = IDNAToASCII.call(this, buffer);\\n          buffer = \\\"\\\";\\n          state = \\\"relative path start\\\";\\n          if (stateOverride) {\\n            break loop;\\n          }\\n          continue;\\n        } else if (\\\"\\\\t\\\" != c && \\\"\\\\n\\\" != c && \\\"\\\\r\\\" != c) {\\n          if (\\\"[\\\" == c) {\\n            seenBracket = true;\\n          } else if (\\\"]\\\" == c) {\\n            seenBracket = false;\\n          }\\n          buffer += c;\\n        } else {\\n          err(\\\"Invalid code point in host/hostname: \\\" + c);\\n        }\\n        break;\\n\\n       case \\\"port\\\":\\n        if (/[0-9]/.test(c)) {\\n          buffer += c;\\n        } else if (EOF == c || \\\"/\\\" == c || \\\"\\\\\\\\\\\" == c || \\\"?\\\" == c || \\\"#\\\" == c || stateOverride) {\\n          if (\\\"\\\" != buffer) {\\n            var temp = parseInt(buffer, 10);\\n            if (temp != relative[this._scheme]) {\\n              this._port = temp + \\\"\\\";\\n            }\\n            buffer = \\\"\\\";\\n          }\\n          if (stateOverride) {\\n            break loop;\\n          }\\n          state = \\\"relative path start\\\";\\n          continue;\\n        } else if (\\\"\\\\t\\\" == c || \\\"\\\\n\\\" == c || \\\"\\\\r\\\" == c) {\\n          err(\\\"Invalid code point in port: \\\" + c);\\n        } else {\\n          invalid.call(this);\\n        }\\n        break;\\n\\n       case \\\"relative path start\\\":\\n        if (\\\"\\\\\\\\\\\" == c) err(\\\"'\\\\\\\\' not allowed in path.\\\");\\n        state = \\\"relative path\\\";\\n        if (\\\"/\\\" != c && \\\"\\\\\\\\\\\" != c) {\\n          continue;\\n        }\\n        break;\\n\\n       case \\\"relative path\\\":\\n        if (EOF == c || \\\"/\\\" == c || \\\"\\\\\\\\\\\" == c || !stateOverride && (\\\"?\\\" == c || \\\"#\\\" == c)) {\\n          if (\\\"\\\\\\\\\\\" == c) {\\n            err(\\\"\\\\\\\\ not allowed in relative path.\\\");\\n          }\\n          var tmp;\\n          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\\n            buffer = tmp;\\n          }\\n          if (\\\"..\\\" == buffer) {\\n            this._path.pop();\\n            if (\\\"/\\\" != c && \\\"\\\\\\\\\\\" != c) {\\n              this._path.push(\\\"\\\");\\n            }\\n          } else if (\\\".\\\" == buffer && \\\"/\\\" != c && \\\"\\\\\\\\\\\" != c) {\\n            this._path.push(\\\"\\\");\\n          } else if (\\\".\\\" != buffer) {\\n            if (\\\"file\\\" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == \\\"|\\\") {\\n              buffer = buffer[0] + \\\":\\\";\\n            }\\n            this._path.push(buffer);\\n          }\\n          buffer = \\\"\\\";\\n          if (\\\"?\\\" == c) {\\n            this._query = \\\"?\\\";\\n            state = \\\"query\\\";\\n          } else if (\\\"#\\\" == c) {\\n            this._fragment = \\\"#\\\";\\n            state = \\\"fragment\\\";\\n          }\\n        } else if (\\\"\\\\t\\\" != c && \\\"\\\\n\\\" != c && \\\"\\\\r\\\" != c) {\\n          buffer += percentEscape(c);\\n        }\\n        break;\\n\\n       case \\\"query\\\":\\n        if (!stateOverride && \\\"#\\\" == c) {\\n          this._fragment = \\\"#\\\";\\n          state = \\\"fragment\\\";\\n        } else if (EOF != c && \\\"\\\\t\\\" != c && \\\"\\\\n\\\" != c && \\\"\\\\r\\\" != c) {\\n          this._query += percentEscapeQuery(c);\\n        }\\n        break;\\n\\n       case \\\"fragment\\\":\\n        if (EOF != c && \\\"\\\\t\\\" != c && \\\"\\\\n\\\" != c && \\\"\\\\r\\\" != c) {\\n          this._fragment += c;\\n        }\\n        break;\\n      }\\n      cursor++;\\n    }\\n  }\\n  function clear() {\\n    this._scheme = \\\"\\\";\\n    this._schemeData = \\\"\\\";\\n    this._username = \\\"\\\";\\n    this._password = null;\\n    this._host = \\\"\\\";\\n    this._port = \\\"\\\";\\n    this._path = [];\\n    this._query = \\\"\\\";\\n    this._fragment = \\\"\\\";\\n    this._isInvalid = false;\\n    this._isRelative = false;\\n  }\\n  function jURL(url, base) {\\n    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\\n    this._url = url;\\n    clear.call(this);\\n    var input = url.replace(/^[ \\\\t\\\\r\\\\n\\\\f]+|[ \\\\t\\\\r\\\\n\\\\f]+$/g, \\\"\\\");\\n    parse.call(this, input, null, base);\\n  }\\n  jURL.prototype = {\\n    toString: function() {\\n      return this.href;\\n    },\\n    get href() {\\n      if (this._isInvalid) return this._url;\\n      var authority = \\\"\\\";\\n      if (\\\"\\\" != this._username || null != this._password) {\\n        authority = this._username + (null != this._password ? \\\":\\\" + this._password : \\\"\\\") + \\\"@\\\";\\n      }\\n      return this.protocol + (this._isRelative ? \\\"//\\\" + authority + this.host : \\\"\\\") + this.pathname + this._query + this._fragment;\\n    },\\n    set href(href) {\\n      clear.call(this);\\n      parse.call(this, href);\\n    },\\n    get protocol() {\\n      return this._scheme + \\\":\\\";\\n    },\\n    set protocol(protocol) {\\n      if (this._isInvalid) return;\\n      parse.call(this, protocol + \\\":\\\", \\\"scheme start\\\");\\n    },\\n    get host() {\\n      return this._isInvalid ? \\\"\\\" : this._port ? this._host + \\\":\\\" + this._port : this._host;\\n    },\\n    set host(host) {\\n      if (this._isInvalid || !this._isRelative) return;\\n      parse.call(this, host, \\\"host\\\");\\n    },\\n    get hostname() {\\n      return this._host;\\n    },\\n    set hostname(hostname) {\\n      if (this._isInvalid || !this._isRelative) return;\\n      parse.call(this, hostname, \\\"hostname\\\");\\n    },\\n    get port() {\\n      return this._port;\\n    },\\n    set port(port) {\\n      if (this._isInvalid || !this._isRelative) return;\\n      parse.call(this, port, \\\"port\\\");\\n    },\\n    get pathname() {\\n      return this._isInvalid ? \\\"\\\" : this._isRelative ? \\\"/\\\" + this._path.join(\\\"/\\\") : this._schemeData;\\n    },\\n    set pathname(pathname) {\\n      if (this._isInvalid || !this._isRelative) return;\\n      this._path = [];\\n      parse.call(this, pathname, \\\"relative path start\\\");\\n    },\\n    get search() {\\n      return this._isInvalid || !this._query || \\\"?\\\" == this._query ? \\\"\\\" : this._query;\\n    },\\n    set search(search) {\\n      if (this._isInvalid || !this._isRelative) return;\\n      this._query = \\\"?\\\";\\n      if (\\\"?\\\" == search[0]) search = search.slice(1);\\n      parse.call(this, search, \\\"query\\\");\\n    },\\n    get hash() {\\n      return this._isInvalid || !this._fragment || \\\"#\\\" == this._fragment ? \\\"\\\" : this._fragment;\\n    },\\n    set hash(hash) {\\n      if (this._isInvalid) return;\\n      this._fragment = \\\"#\\\";\\n      if (\\\"#\\\" == hash[0]) hash = hash.slice(1);\\n      parse.call(this, hash, \\\"fragment\\\");\\n    },\\n    get origin() {\\n      var host;\\n      if (this._isInvalid || !this._scheme) {\\n        return \\\"\\\";\\n      }\\n      switch (this._scheme) {\\n       case \\\"data\\\":\\n       case \\\"file\\\":\\n       case \\\"javascript\\\":\\n       case \\\"mailto\\\":\\n        return \\\"null\\\";\\n      }\\n      host = this.host;\\n      if (!host) {\\n        return \\\"\\\";\\n      }\\n      return this._scheme + \\\"://\\\" + host;\\n    }\\n  };\\n  var OriginalURL = scope.URL;\\n  if (OriginalURL) {\\n    jURL.createObjectURL = function(blob) {\\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\\n    };\\n    jURL.revokeObjectURL = function(url) {\\n      OriginalURL.revokeObjectURL(url);\\n    };\\n  }\\n  scope.URL = jURL;\\n})(self);\\n\\n(function(global) {\\n  if (global.JsMutationObserver) {\\n    return;\\n  }\\n  var registrationsTable = new WeakMap();\\n  var setImmediate;\\n  if (/Trident|Edge/.test(navigator.userAgent)) {\\n    setImmediate = setTimeout;\\n  } else if (window.setImmediate) {\\n    setImmediate = window.setImmediate;\\n  } else {\\n    var setImmediateQueue = [];\\n    var sentinel = String(Math.random());\\n    window.addEventListener(\\\"message\\\", function(e) {\\n      if (e.data === sentinel) {\\n        var queue = setImmediateQueue;\\n        setImmediateQueue = [];\\n        queue.forEach(function(func) {\\n          func();\\n        });\\n      }\\n    });\\n    setImmediate = function(func) {\\n      setImmediateQueue.push(func);\\n      window.postMessage(sentinel, \\\"*\\\");\\n    };\\n  }\\n  var isScheduled = false;\\n  var scheduledObservers = [];\\n  function scheduleCallback(observer) {\\n    scheduledObservers.push(observer);\\n    if (!isScheduled) {\\n      isScheduled = true;\\n      setImmediate(dispatchCallbacks);\\n    }\\n  }\\n  function wrapIfNeeded(node) {\\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\\n  }\\n  function dispatchCallbacks() {\\n    isScheduled = false;\\n    var observers = scheduledObservers;\\n    scheduledObservers = [];\\n    observers.sort(function(o1, o2) {\\n      return o1.uid_ - o2.uid_;\\n    });\\n    var anyNonEmpty = false;\\n    observers.forEach(function(observer) {\\n      var queue = observer.takeRecords();\\n      removeTransientObserversFor(observer);\\n      if (queue.length) {\\n        observer.callback_(queue, observer);\\n        anyNonEmpty = true;\\n      }\\n    });\\n    if (anyNonEmpty) dispatchCallbacks();\\n  }\\n  function removeTransientObserversFor(observer) {\\n    observer.nodes_.forEach(function(node) {\\n      var registrations = registrationsTable.get(node);\\n      if (!registrations) return;\\n      registrations.forEach(function(registration) {\\n        if (registration.observer === observer) registration.removeTransientObservers();\\n      });\\n    });\\n  }\\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\\n    for (var node = target; node; node = node.parentNode) {\\n      var registrations = registrationsTable.get(node);\\n      if (registrations) {\\n        for (var j = 0; j < registrations.length; j++) {\\n          var registration = registrations[j];\\n          var options = registration.options;\\n          if (node !== target && !options.subtree) continue;\\n          var record = callback(options);\\n          if (record) registration.enqueue(record);\\n        }\\n      }\\n    }\\n  }\\n  var uidCounter = 0;\\n  function JsMutationObserver(callback) {\\n    this.callback_ = callback;\\n    this.nodes_ = [];\\n    this.records_ = [];\\n    this.uid_ = ++uidCounter;\\n  }\\n  JsMutationObserver.prototype = {\\n    observe: function(target, options) {\\n      target = wrapIfNeeded(target);\\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\\n        throw new SyntaxError();\\n      }\\n      var registrations = registrationsTable.get(target);\\n      if (!registrations) registrationsTable.set(target, registrations = []);\\n      var registration;\\n      for (var i = 0; i < registrations.length; i++) {\\n        if (registrations[i].observer === this) {\\n          registration = registrations[i];\\n          registration.removeListeners();\\n          registration.options = options;\\n          break;\\n        }\\n      }\\n      if (!registration) {\\n        registration = new Registration(this, target, options);\\n        registrations.push(registration);\\n        this.nodes_.push(target);\\n      }\\n      registration.addListeners();\\n    },\\n    disconnect: function() {\\n      this.nodes_.forEach(function(node) {\\n        var registrations = registrationsTable.get(node);\\n        for (var i = 0; i < registrations.length; i++) {\\n          var registration = registrations[i];\\n          if (registration.observer === this) {\\n            registration.removeListeners();\\n            registrations.splice(i, 1);\\n            break;\\n          }\\n        }\\n      }, this);\\n      this.records_ = [];\\n    },\\n    takeRecords: function() {\\n      var copyOfRecords = this.records_;\\n      this.records_ = [];\\n      return copyOfRecords;\\n    }\\n  };\\n  function MutationRecord(type, target) {\\n    this.type = type;\\n    this.target = target;\\n    this.addedNodes = [];\\n    this.removedNodes = [];\\n    this.previousSibling = null;\\n    this.nextSibling = null;\\n    this.attributeName = null;\\n    this.attributeNamespace = null;\\n    this.oldValue = null;\\n  }\\n  function copyMutationRecord(original) {\\n    var record = new MutationRecord(original.type, original.target);\\n    record.addedNodes = original.addedNodes.slice();\\n    record.removedNodes = original.removedNodes.slice();\\n    record.previousSibling = original.previousSibling;\\n    record.nextSibling = original.nextSibling;\\n    record.attributeName = original.attributeName;\\n    record.attributeNamespace = original.attributeNamespace;\\n    record.oldValue = original.oldValue;\\n    return record;\\n  }\\n  var currentRecord, recordWithOldValue;\\n  function getRecord(type, target) {\\n    return currentRecord = new MutationRecord(type, target);\\n  }\\n  function getRecordWithOldValue(oldValue) {\\n    if (recordWithOldValue) return recordWithOldValue;\\n    recordWithOldValue = copyMutationRecord(currentRecord);\\n    recordWithOldValue.oldValue = oldValue;\\n    return recordWithOldValue;\\n  }\\n  function clearRecords() {\\n    currentRecord = recordWithOldValue = undefined;\\n  }\\n  function recordRepresentsCurrentMutation(record) {\\n    return record === recordWithOldValue || record === currentRecord;\\n  }\\n  function selectRecord(lastRecord, newRecord) {\\n    if (lastRecord === newRecord) return lastRecord;\\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\\n    return null;\\n  }\\n  function Registration(observer, target, options) {\\n    this.observer = observer;\\n    this.target = target;\\n    this.options = options;\\n    this.transientObservedNodes = [];\\n  }\\n  Registration.prototype = {\\n    enqueue: function(record) {\\n      var records = this.observer.records_;\\n      var length = records.length;\\n      if (records.length > 0) {\\n        var lastRecord = records[length - 1];\\n        var recordToReplaceLast = selectRecord(lastRecord, record);\\n        if (recordToReplaceLast) {\\n          records[length - 1] = recordToReplaceLast;\\n          return;\\n        }\\n      } else {\\n        scheduleCallback(this.observer);\\n      }\\n      records[length] = record;\\n    },\\n    addListeners: function() {\\n      this.addListeners_(this.target);\\n    },\\n    addListeners_: function(node) {\\n      var options = this.options;\\n      if (options.attributes) node.addEventListener(\\\"DOMAttrModified\\\", this, true);\\n      if (options.characterData) node.addEventListener(\\\"DOMCharacterDataModified\\\", this, true);\\n      if (options.childList) node.addEventListener(\\\"DOMNodeInserted\\\", this, true);\\n      if (options.childList || options.subtree) node.addEventListener(\\\"DOMNodeRemoved\\\", this, true);\\n    },\\n    removeListeners: function() {\\n      this.removeListeners_(this.target);\\n    },\\n    removeListeners_: function(node) {\\n      var options = this.options;\\n      if (options.attributes) node.removeEventListener(\\\"DOMAttrModified\\\", this, true);\\n      if (options.characterData) node.removeEventListener(\\\"DOMCharacterDataModified\\\", this, true);\\n      if (options.childList) node.removeEventListener(\\\"DOMNodeInserted\\\", this, true);\\n      if (options.childList || options.subtree) node.removeEventListener(\\\"DOMNodeRemoved\\\", this, true);\\n    },\\n    addTransientObserver: function(node) {\\n      if (node === this.target) return;\\n      this.addListeners_(node);\\n      this.transientObservedNodes.push(node);\\n      var registrations = registrationsTable.get(node);\\n      if (!registrations) registrationsTable.set(node, registrations = []);\\n      registrations.push(this);\\n    },\\n    removeTransientObservers: function() {\\n      var transientObservedNodes = this.transientObservedNodes;\\n      this.transientObservedNodes = [];\\n      transientObservedNodes.forEach(function(node) {\\n        this.removeListeners_(node);\\n        var registrations = registrationsTable.get(node);\\n        for (var i = 0; i < registrations.length; i++) {\\n          if (registrations[i] === this) {\\n            registrations.splice(i, 1);\\n            break;\\n          }\\n        }\\n      }, this);\\n    },\\n    handleEvent: function(e) {\\n      e.stopImmediatePropagation();\\n      switch (e.type) {\\n       case \\\"DOMAttrModified\\\":\\n        var name = e.attrName;\\n        var namespace = e.relatedNode.namespaceURI;\\n        var target = e.target;\\n        var record = new getRecord(\\\"attributes\\\", target);\\n        record.attributeName = name;\\n        record.attributeNamespace = namespace;\\n        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\\n          if (!options.attributes) return;\\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\\n            return;\\n          }\\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\\n          return record;\\n        });\\n        break;\\n\\n       case \\\"DOMCharacterDataModified\\\":\\n        var target = e.target;\\n        var record = getRecord(\\\"characterData\\\", target);\\n        var oldValue = e.prevValue;\\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\\n          if (!options.characterData) return;\\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\\n          return record;\\n        });\\n        break;\\n\\n       case \\\"DOMNodeRemoved\\\":\\n        this.addTransientObserver(e.target);\\n\\n       case \\\"DOMNodeInserted\\\":\\n        var changedNode = e.target;\\n        var addedNodes, removedNodes;\\n        if (e.type === \\\"DOMNodeInserted\\\") {\\n          addedNodes = [ changedNode ];\\n          removedNodes = [];\\n        } else {\\n          addedNodes = [];\\n          removedNodes = [ changedNode ];\\n        }\\n        var previousSibling = changedNode.previousSibling;\\n        var nextSibling = changedNode.nextSibling;\\n        var record = getRecord(\\\"childList\\\", e.target.parentNode);\\n        record.addedNodes = addedNodes;\\n        record.removedNodes = removedNodes;\\n        record.previousSibling = previousSibling;\\n        record.nextSibling = nextSibling;\\n        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\\n          if (!options.childList) return;\\n          return record;\\n        });\\n      }\\n      clearRecords();\\n    }\\n  };\\n  global.JsMutationObserver = JsMutationObserver;\\n  if (!global.MutationObserver) {\\n    global.MutationObserver = JsMutationObserver;\\n    JsMutationObserver._isPolyfilled = true;\\n  }\\n})(self);\\n\\n(function(scope) {\\n  \\\"use strict\\\";\\n  if (!(window.performance && window.performance.now)) {\\n    var start = Date.now();\\n    window.performance = {\\n      now: function() {\\n        return Date.now() - start;\\n      }\\n    };\\n  }\\n  if (!window.requestAnimationFrame) {\\n    window.requestAnimationFrame = function() {\\n      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\\n      return nativeRaf ? function(callback) {\\n        return nativeRaf(function() {\\n          callback(performance.now());\\n        });\\n      } : function(callback) {\\n        return window.setTimeout(callback, 1e3 / 60);\\n      };\\n    }();\\n  }\\n  if (!window.cancelAnimationFrame) {\\n    window.cancelAnimationFrame = function() {\\n      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\\n        clearTimeout(id);\\n      };\\n    }();\\n  }\\n  var workingDefaultPrevented = function() {\\n    var e = document.createEvent(\\\"Event\\\");\\n    e.initEvent(\\\"foo\\\", true, true);\\n    e.preventDefault();\\n    return e.defaultPrevented;\\n  }();\\n  if (!workingDefaultPrevented) {\\n    var origPreventDefault = Event.prototype.preventDefault;\\n    Event.prototype.preventDefault = function() {\\n      if (!this.cancelable) {\\n        return;\\n      }\\n      origPreventDefault.call(this);\\n      Object.defineProperty(this, \\\"defaultPrevented\\\", {\\n        get: function() {\\n          return true;\\n        },\\n        configurable: true\\n      });\\n    };\\n  }\\n  var isIE = /Trident/.test(navigator.userAgent);\\n  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== \\\"function\\\") {\\n    window.CustomEvent = function(inType, params) {\\n      params = params || {};\\n      var e = document.createEvent(\\\"CustomEvent\\\");\\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\\n      return e;\\n    };\\n    window.CustomEvent.prototype = window.Event.prototype;\\n  }\\n  if (!window.Event || isIE && typeof window.Event !== \\\"function\\\") {\\n    var origEvent = window.Event;\\n    window.Event = function(inType, params) {\\n      params = params || {};\\n      var e = document.createEvent(\\\"Event\\\");\\n      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\\n      return e;\\n    };\\n    window.Event.prototype = origEvent.prototype;\\n  }\\n})(window.WebComponents);\\n\\nwindow.HTMLImports = window.HTMLImports || {\\n  flags: {}\\n};\\n\\n(function(scope) {\\n  var IMPORT_LINK_TYPE = \\\"import\\\";\\n  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(\\\"link\\\"));\\n  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\\n  var wrap = function(node) {\\n    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\\n  };\\n  var rootDocument = wrap(document);\\n  var currentScriptDescriptor = {\\n    get: function() {\\n      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== \\\"complete\\\" ? document.scripts[document.scripts.length - 1] : null);\\n      return wrap(script);\\n    },\\n    configurable: true\\n  };\\n  Object.defineProperty(document, \\\"_currentScript\\\", currentScriptDescriptor);\\n  Object.defineProperty(rootDocument, \\\"_currentScript\\\", currentScriptDescriptor);\\n  var isIE = /Trident/.test(navigator.userAgent);\\n  function whenReady(callback, doc) {\\n    doc = doc || rootDocument;\\n    whenDocumentReady(function() {\\n      watchImportsLoad(callback, doc);\\n    }, doc);\\n  }\\n  var requiredReadyState = isIE ? \\\"complete\\\" : \\\"interactive\\\";\\n  var READY_EVENT = \\\"readystatechange\\\";\\n  function isDocumentReady(doc) {\\n    return doc.readyState === \\\"complete\\\" || doc.readyState === requiredReadyState;\\n  }\\n  function whenDocumentReady(callback, doc) {\\n    if (!isDocumentReady(doc)) {\\n      var checkReady = function() {\\n        if (doc.readyState === \\\"complete\\\" || doc.readyState === requiredReadyState) {\\n          doc.removeEventListener(READY_EVENT, checkReady);\\n          whenDocumentReady(callback, doc);\\n        }\\n      };\\n      doc.addEventListener(READY_EVENT, checkReady);\\n    } else if (callback) {\\n      callback();\\n    }\\n  }\\n  function markTargetLoaded(event) {\\n    event.target.__loaded = true;\\n  }\\n  function watchImportsLoad(callback, doc) {\\n    var imports = doc.querySelectorAll(\\\"link[rel=import]\\\");\\n    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\\n    function checkDone() {\\n      if (parsedCount == importCount && callback) {\\n        callback({\\n          allImports: imports,\\n          loadedImports: newImports,\\n          errorImports: errorImports\\n        });\\n      }\\n    }\\n    function loadedImport(e) {\\n      markTargetLoaded(e);\\n      newImports.push(this);\\n      parsedCount++;\\n      checkDone();\\n    }\\n    function errorLoadingImport(e) {\\n      errorImports.push(this);\\n      parsedCount++;\\n      checkDone();\\n    }\\n    if (importCount) {\\n      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\\n        if (isImportLoaded(imp)) {\\n          newImports.push(this);\\n          parsedCount++;\\n          checkDone();\\n        } else {\\n          imp.addEventListener(\\\"load\\\", loadedImport);\\n          imp.addEventListener(\\\"error\\\", errorLoadingImport);\\n        }\\n      }\\n    } else {\\n      checkDone();\\n    }\\n  }\\n  function isImportLoaded(link) {\\n    return useNative ? link.__loaded || link.import && link.import.readyState !== \\\"loading\\\" : link.__importParsed;\\n  }\\n  if (useNative) {\\n    new MutationObserver(function(mxns) {\\n      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\\n        if (m.addedNodes) {\\n          handleImports(m.addedNodes);\\n        }\\n      }\\n    }).observe(document.head, {\\n      childList: true\\n    });\\n    function handleImports(nodes) {\\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\\n        if (isImport(n)) {\\n          handleImport(n);\\n        }\\n      }\\n    }\\n    function isImport(element) {\\n      return element.localName === \\\"link\\\" && element.rel === \\\"import\\\";\\n    }\\n    function handleImport(element) {\\n      var loaded = element.import;\\n      if (loaded) {\\n        markTargetLoaded({\\n          target: element\\n        });\\n      } else {\\n        element.addEventListener(\\\"load\\\", markTargetLoaded);\\n        element.addEventListener(\\\"error\\\", markTargetLoaded);\\n      }\\n    }\\n    (function() {\\n      if (document.readyState === \\\"loading\\\") {\\n        var imports = document.querySelectorAll(\\\"link[rel=import]\\\");\\n        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\\n          handleImport(imp);\\n        }\\n      }\\n    })();\\n  }\\n  whenReady(function(detail) {\\n    window.HTMLImports.ready = true;\\n    window.HTMLImports.readyTime = new Date().getTime();\\n    var evt = rootDocument.createEvent(\\\"CustomEvent\\\");\\n    evt.initCustomEvent(\\\"HTMLImportsLoaded\\\", true, true, detail);\\n    rootDocument.dispatchEvent(evt);\\n  });\\n  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\\n  scope.useNative = useNative;\\n  scope.rootDocument = rootDocument;\\n  scope.whenReady = whenReady;\\n  scope.isIE = isIE;\\n})(window.HTMLImports);\\n\\n(function(scope) {\\n  var modules = [];\\n  var addModule = function(module) {\\n    modules.push(module);\\n  };\\n  var initializeModules = function() {\\n    modules.forEach(function(module) {\\n      module(scope);\\n    });\\n  };\\n  scope.addModule = addModule;\\n  scope.initializeModules = initializeModules;\\n})(window.HTMLImports);\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var CSS_URL_REGEXP = /(url\\\\()([^)]*)(\\\\))/g;\\n  var CSS_IMPORT_REGEXP = /(@import[\\\\s]+(?!url\\\\())([^;]*)(;)/g;\\n  var path = {\\n    resolveUrlsInStyle: function(style, linkUrl) {\\n      var doc = style.ownerDocument;\\n      var resolver = doc.createElement(\\\"a\\\");\\n      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\\n      return style;\\n    },\\n    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\\n      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\\n      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\\n      return r;\\n    },\\n    replaceUrls: function(text, urlObj, linkUrl, regexp) {\\n      return text.replace(regexp, function(m, pre, url, post) {\\n        var urlPath = url.replace(/[\\\"']/g, \\\"\\\");\\n        if (linkUrl) {\\n          urlPath = new URL(urlPath, linkUrl).href;\\n        }\\n        urlObj.href = urlPath;\\n        urlPath = urlObj.href;\\n        return pre + \\\"'\\\" + urlPath + \\\"'\\\" + post;\\n      });\\n    }\\n  };\\n  scope.path = path;\\n});\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var xhr = {\\n    async: true,\\n    ok: function(request) {\\n      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\\n    },\\n    load: function(url, next, nextContext) {\\n      var request = new XMLHttpRequest();\\n      if (scope.flags.debug || scope.flags.bust) {\\n        url += \\\"?\\\" + Math.random();\\n      }\\n      request.open(\\\"GET\\\", url, xhr.async);\\n      request.addEventListener(\\\"readystatechange\\\", function(e) {\\n        if (request.readyState === 4) {\\n          var redirectedUrl = null;\\n          try {\\n            var locationHeader = request.getResponseHeader(\\\"Location\\\");\\n            if (locationHeader) {\\n              redirectedUrl = locationHeader.substr(0, 1) === \\\"/\\\" ? location.origin + locationHeader : locationHeader;\\n            }\\n          } catch (e) {\\n            console.error(e.message);\\n          }\\n          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\\n        }\\n      });\\n      request.send();\\n      return request;\\n    },\\n    loadDocument: function(url, next, nextContext) {\\n      this.load(url, next, nextContext).responseType = \\\"document\\\";\\n    }\\n  };\\n  scope.xhr = xhr;\\n});\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var xhr = scope.xhr;\\n  var flags = scope.flags;\\n  var Loader = function(onLoad, onComplete) {\\n    this.cache = {};\\n    this.onload = onLoad;\\n    this.oncomplete = onComplete;\\n    this.inflight = 0;\\n    this.pending = {};\\n  };\\n  Loader.prototype = {\\n    addNodes: function(nodes) {\\n      this.inflight += nodes.length;\\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\\n        this.require(n);\\n      }\\n      this.checkDone();\\n    },\\n    addNode: function(node) {\\n      this.inflight++;\\n      this.require(node);\\n      this.checkDone();\\n    },\\n    require: function(elt) {\\n      var url = elt.src || elt.href;\\n      elt.__nodeUrl = url;\\n      if (!this.dedupe(url, elt)) {\\n        this.fetch(url, elt);\\n      }\\n    },\\n    dedupe: function(url, elt) {\\n      if (this.pending[url]) {\\n        this.pending[url].push(elt);\\n        return true;\\n      }\\n      var resource;\\n      if (this.cache[url]) {\\n        this.onload(url, elt, this.cache[url]);\\n        this.tail();\\n        return true;\\n      }\\n      this.pending[url] = [ elt ];\\n      return false;\\n    },\\n    fetch: function(url, elt) {\\n      flags.load && console.log(\\\"fetch\\\", url, elt);\\n      if (!url) {\\n        setTimeout(function() {\\n          this.receive(url, elt, {\\n            error: \\\"href must be specified\\\"\\n          }, null);\\n        }.bind(this), 0);\\n      } else if (url.match(/^data:/)) {\\n        var pieces = url.split(\\\",\\\");\\n        var header = pieces[0];\\n        var body = pieces[1];\\n        if (header.indexOf(\\\";base64\\\") > -1) {\\n          body = atob(body);\\n        } else {\\n          body = decodeURIComponent(body);\\n        }\\n        setTimeout(function() {\\n          this.receive(url, elt, null, body);\\n        }.bind(this), 0);\\n      } else {\\n        var receiveXhr = function(err, resource, redirectedUrl) {\\n          this.receive(url, elt, err, resource, redirectedUrl);\\n        }.bind(this);\\n        xhr.load(url, receiveXhr);\\n      }\\n    },\\n    receive: function(url, elt, err, resource, redirectedUrl) {\\n      this.cache[url] = resource;\\n      var $p = this.pending[url];\\n      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\\n        this.onload(url, p, resource, err, redirectedUrl);\\n        this.tail();\\n      }\\n      this.pending[url] = null;\\n    },\\n    tail: function() {\\n      --this.inflight;\\n      this.checkDone();\\n    },\\n    checkDone: function() {\\n      if (!this.inflight) {\\n        this.oncomplete();\\n      }\\n    }\\n  };\\n  scope.Loader = Loader;\\n});\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var Observer = function(addCallback) {\\n    this.addCallback = addCallback;\\n    this.mo = new MutationObserver(this.handler.bind(this));\\n  };\\n  Observer.prototype = {\\n    handler: function(mutations) {\\n      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\\n        if (m.type === \\\"childList\\\" && m.addedNodes.length) {\\n          this.addedNodes(m.addedNodes);\\n        }\\n      }\\n    },\\n    addedNodes: function(nodes) {\\n      if (this.addCallback) {\\n        this.addCallback(nodes);\\n      }\\n      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\\n        if (n.children && n.children.length) {\\n          this.addedNodes(n.children);\\n        }\\n      }\\n    },\\n    observe: function(root) {\\n      this.mo.observe(root, {\\n        childList: true,\\n        subtree: true\\n      });\\n    }\\n  };\\n  scope.Observer = Observer;\\n});\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var path = scope.path;\\n  var rootDocument = scope.rootDocument;\\n  var flags = scope.flags;\\n  var isIE = scope.isIE;\\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\\n  var IMPORT_SELECTOR = \\\"link[rel=\\\" + IMPORT_LINK_TYPE + \\\"]\\\";\\n  var importParser = {\\n    documentSelectors: IMPORT_SELECTOR,\\n    importsSelectors: [ IMPORT_SELECTOR, \\\"link[rel=stylesheet]:not([type])\\\", \\\"style:not([type])\\\", \\\"script:not([type])\\\", 'script[type=\\\"application/javascript\\\"]', 'script[type=\\\"text/javascript\\\"]' ].join(\\\",\\\"),\\n    map: {\\n      link: \\\"parseLink\\\",\\n      script: \\\"parseScript\\\",\\n      style: \\\"parseStyle\\\"\\n    },\\n    dynamicElements: [],\\n    parseNext: function() {\\n      var next = this.nextToParse();\\n      if (next) {\\n        this.parse(next);\\n      }\\n    },\\n    parse: function(elt) {\\n      if (this.isParsed(elt)) {\\n        flags.parse && console.log(\\\"[%s] is already parsed\\\", elt.localName);\\n        return;\\n      }\\n      var fn = this[this.map[elt.localName]];\\n      if (fn) {\\n        this.markParsing(elt);\\n        fn.call(this, elt);\\n      }\\n    },\\n    parseDynamic: function(elt, quiet) {\\n      this.dynamicElements.push(elt);\\n      if (!quiet) {\\n        this.parseNext();\\n      }\\n    },\\n    markParsing: function(elt) {\\n      flags.parse && console.log(\\\"parsing\\\", elt);\\n      this.parsingElement = elt;\\n    },\\n    markParsingComplete: function(elt) {\\n      elt.__importParsed = true;\\n      this.markDynamicParsingComplete(elt);\\n      if (elt.__importElement) {\\n        elt.__importElement.__importParsed = true;\\n        this.markDynamicParsingComplete(elt.__importElement);\\n      }\\n      this.parsingElement = null;\\n      flags.parse && console.log(\\\"completed\\\", elt);\\n    },\\n    markDynamicParsingComplete: function(elt) {\\n      var i = this.dynamicElements.indexOf(elt);\\n      if (i >= 0) {\\n        this.dynamicElements.splice(i, 1);\\n      }\\n    },\\n    parseImport: function(elt) {\\n      elt.import = elt.__doc;\\n      if (window.HTMLImports.__importsParsingHook) {\\n        window.HTMLImports.__importsParsingHook(elt);\\n      }\\n      if (elt.import) {\\n        elt.import.__importParsed = true;\\n      }\\n      this.markParsingComplete(elt);\\n      if (elt.__resource && !elt.__error) {\\n        elt.dispatchEvent(new CustomEvent(\\\"load\\\", {\\n          bubbles: false\\n        }));\\n      } else {\\n        elt.dispatchEvent(new CustomEvent(\\\"error\\\", {\\n          bubbles: false\\n        }));\\n      }\\n      if (elt.__pending) {\\n        var fn;\\n        while (elt.__pending.length) {\\n          fn = elt.__pending.shift();\\n          if (fn) {\\n            fn({\\n              target: elt\\n            });\\n          }\\n        }\\n      }\\n      this.parseNext();\\n    },\\n    parseLink: function(linkElt) {\\n      if (nodeIsImport(linkElt)) {\\n        this.parseImport(linkElt);\\n      } else {\\n        linkElt.href = linkElt.href;\\n        this.parseGeneric(linkElt);\\n      }\\n    },\\n    parseStyle: function(elt) {\\n      var src = elt;\\n      elt = cloneStyle(elt);\\n      src.__appliedElement = elt;\\n      elt.__importElement = src;\\n      this.parseGeneric(elt);\\n    },\\n    parseGeneric: function(elt) {\\n      this.trackElement(elt);\\n      this.addElementToDocument(elt);\\n    },\\n    rootImportForElement: function(elt) {\\n      var n = elt;\\n      while (n.ownerDocument.__importLink) {\\n        n = n.ownerDocument.__importLink;\\n      }\\n      return n;\\n    },\\n    addElementToDocument: function(elt) {\\n      var port = this.rootImportForElement(elt.__importElement || elt);\\n      port.parentNode.insertBefore(elt, port);\\n    },\\n    trackElement: function(elt, callback) {\\n      var self = this;\\n      var done = function(e) {\\n        elt.removeEventListener(\\\"load\\\", done);\\n        elt.removeEventListener(\\\"error\\\", done);\\n        if (callback) {\\n          callback(e);\\n        }\\n        self.markParsingComplete(elt);\\n        self.parseNext();\\n      };\\n      elt.addEventListener(\\\"load\\\", done);\\n      elt.addEventListener(\\\"error\\\", done);\\n      if (isIE && elt.localName === \\\"style\\\") {\\n        var fakeLoad = false;\\n        if (elt.textContent.indexOf(\\\"@import\\\") == -1) {\\n          fakeLoad = true;\\n        } else if (elt.sheet) {\\n          fakeLoad = true;\\n          var csr = elt.sheet.cssRules;\\n          var len = csr ? csr.length : 0;\\n          for (var i = 0, r; i < len && (r = csr[i]); i++) {\\n            if (r.type === CSSRule.IMPORT_RULE) {\\n              fakeLoad = fakeLoad && Boolean(r.styleSheet);\\n            }\\n          }\\n        }\\n        if (fakeLoad) {\\n          setTimeout(function() {\\n            elt.dispatchEvent(new CustomEvent(\\\"load\\\", {\\n              bubbles: false\\n            }));\\n          });\\n        }\\n      }\\n    },\\n    parseScript: function(scriptElt) {\\n      var script = document.createElement(\\\"script\\\");\\n      script.__importElement = scriptElt;\\n      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\\n      scope.currentScript = scriptElt;\\n      this.trackElement(script, function(e) {\\n        if (script.parentNode) {\\n          script.parentNode.removeChild(script);\\n        }\\n        scope.currentScript = null;\\n      });\\n      this.addElementToDocument(script);\\n    },\\n    nextToParse: function() {\\n      this._mayParse = [];\\n      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\\n    },\\n    nextToParseInDoc: function(doc, link) {\\n      if (doc && this._mayParse.indexOf(doc) < 0) {\\n        this._mayParse.push(doc);\\n        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\\n        for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\\n          if (!this.isParsed(n)) {\\n            if (this.hasResource(n)) {\\n              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\\n            } else {\\n              return;\\n            }\\n          }\\n        }\\n      }\\n      return link;\\n    },\\n    nextToParseDynamic: function() {\\n      return this.dynamicElements[0];\\n    },\\n    parseSelectorsForNode: function(node) {\\n      var doc = node.ownerDocument || node;\\n      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\\n    },\\n    isParsed: function(node) {\\n      return node.__importParsed;\\n    },\\n    needsDynamicParsing: function(elt) {\\n      return this.dynamicElements.indexOf(elt) >= 0;\\n    },\\n    hasResource: function(node) {\\n      if (nodeIsImport(node) && node.__doc === undefined) {\\n        return false;\\n      }\\n      return true;\\n    }\\n  };\\n  function nodeIsImport(elt) {\\n    return elt.localName === \\\"link\\\" && elt.rel === IMPORT_LINK_TYPE;\\n  }\\n  function generateScriptDataUrl(script) {\\n    var scriptContent = generateScriptContent(script);\\n    return \\\"data:text/javascript;charset=utf-8,\\\" + encodeURIComponent(scriptContent);\\n  }\\n  function generateScriptContent(script) {\\n    return script.textContent + generateSourceMapHint(script);\\n  }\\n  function generateSourceMapHint(script) {\\n    var owner = script.ownerDocument;\\n    owner.__importedScripts = owner.__importedScripts || 0;\\n    var moniker = script.ownerDocument.baseURI;\\n    var num = owner.__importedScripts ? \\\"-\\\" + owner.__importedScripts : \\\"\\\";\\n    owner.__importedScripts++;\\n    return \\\"\\\\n//# sourceURL=\\\" + moniker + num + \\\".js\\\\n\\\";\\n  }\\n  function cloneStyle(style) {\\n    var clone = style.ownerDocument.createElement(\\\"style\\\");\\n    clone.textContent = style.textContent;\\n    path.resolveUrlsInStyle(clone);\\n    return clone;\\n  }\\n  scope.parser = importParser;\\n  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\\n});\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var flags = scope.flags;\\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\\n  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\\n  var rootDocument = scope.rootDocument;\\n  var Loader = scope.Loader;\\n  var Observer = scope.Observer;\\n  var parser = scope.parser;\\n  var importer = {\\n    documents: {},\\n    documentPreloadSelectors: IMPORT_SELECTOR,\\n    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(\\\",\\\"),\\n    loadNode: function(node) {\\n      importLoader.addNode(node);\\n    },\\n    loadSubtree: function(parent) {\\n      var nodes = this.marshalNodes(parent);\\n      importLoader.addNodes(nodes);\\n    },\\n    marshalNodes: function(parent) {\\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\\n    },\\n    loadSelectorsForNode: function(node) {\\n      var doc = node.ownerDocument || node;\\n      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\\n    },\\n    loaded: function(url, elt, resource, err, redirectedUrl) {\\n      flags.load && console.log(\\\"loaded\\\", url, elt);\\n      elt.__resource = resource;\\n      elt.__error = err;\\n      if (isImportLink(elt)) {\\n        var doc = this.documents[url];\\n        if (doc === undefined) {\\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\\n          if (doc) {\\n            doc.__importLink = elt;\\n            this.bootDocument(doc);\\n          }\\n          this.documents[url] = doc;\\n        }\\n        elt.__doc = doc;\\n      }\\n      parser.parseNext();\\n    },\\n    bootDocument: function(doc) {\\n      this.loadSubtree(doc);\\n      this.observer.observe(doc);\\n      parser.parseNext();\\n    },\\n    loadedAll: function() {\\n      parser.parseNext();\\n    }\\n  };\\n  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\\n  importer.observer = new Observer();\\n  function isImportLink(elt) {\\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\\n  }\\n  function isLinkRel(elt, rel) {\\n    return elt.localName === \\\"link\\\" && elt.getAttribute(\\\"rel\\\") === rel;\\n  }\\n  function hasBaseURIAccessor(doc) {\\n    return !!Object.getOwnPropertyDescriptor(doc, \\\"baseURI\\\");\\n  }\\n  function makeDocument(resource, url) {\\n    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\\n    doc._URL = url;\\n    var base = doc.createElement(\\\"base\\\");\\n    base.setAttribute(\\\"href\\\", url);\\n    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\\n      Object.defineProperty(doc, \\\"baseURI\\\", {\\n        value: url\\n      });\\n    }\\n    var meta = doc.createElement(\\\"meta\\\");\\n    meta.setAttribute(\\\"charset\\\", \\\"utf-8\\\");\\n    doc.head.appendChild(meta);\\n    doc.head.appendChild(base);\\n    doc.body.innerHTML = resource;\\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\\n      HTMLTemplateElement.bootstrap(doc);\\n    }\\n    return doc;\\n  }\\n  if (!document.baseURI) {\\n    var baseURIDescriptor = {\\n      get: function() {\\n        var base = document.querySelector(\\\"base\\\");\\n        return base ? base.href : window.location.href;\\n      },\\n      configurable: true\\n    };\\n    Object.defineProperty(document, \\\"baseURI\\\", baseURIDescriptor);\\n    Object.defineProperty(rootDocument, \\\"baseURI\\\", baseURIDescriptor);\\n  }\\n  scope.importer = importer;\\n  scope.importLoader = importLoader;\\n});\\n\\nwindow.HTMLImports.addModule(function(scope) {\\n  var parser = scope.parser;\\n  var importer = scope.importer;\\n  var dynamic = {\\n    added: function(nodes) {\\n      var owner, parsed, loading;\\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\\n        if (!owner) {\\n          owner = n.ownerDocument;\\n          parsed = parser.isParsed(owner);\\n        }\\n        loading = this.shouldLoadNode(n);\\n        if (loading) {\\n          importer.loadNode(n);\\n        }\\n        if (this.shouldParseNode(n) && parsed) {\\n          parser.parseDynamic(n, loading);\\n        }\\n      }\\n    },\\n    shouldLoadNode: function(node) {\\n      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\\n    },\\n    shouldParseNode: function(node) {\\n      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\\n    }\\n  };\\n  importer.observer.addCallback = dynamic.added.bind(dynamic);\\n  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\\n});\\n\\n(function(scope) {\\n  var initializeModules = scope.initializeModules;\\n  var isIE = scope.isIE;\\n  if (scope.useNative) {\\n    return;\\n  }\\n  initializeModules();\\n  var rootDocument = scope.rootDocument;\\n  function bootstrap() {\\n    window.HTMLImports.importer.bootDocument(rootDocument);\\n  }\\n  if (document.readyState === \\\"complete\\\" || document.readyState === \\\"interactive\\\" && !window.attachEvent) {\\n    bootstrap();\\n  } else {\\n    document.addEventListener(\\\"DOMContentLoaded\\\", bootstrap);\\n  }\\n})(window.HTMLImports);\\n\\nwindow.CustomElements = window.CustomElements || {\\n  flags: {}\\n};\\n\\n(function(scope) {\\n  var flags = scope.flags;\\n  var modules = [];\\n  var addModule = function(module) {\\n    modules.push(module);\\n  };\\n  var initializeModules = function() {\\n    modules.forEach(function(module) {\\n      module(scope);\\n    });\\n  };\\n  scope.addModule = addModule;\\n  scope.initializeModules = initializeModules;\\n  scope.hasNative = Boolean(document.registerElement);\\n  scope.isIE = /Trident/.test(navigator.userAgent);\\n  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\\n})(window.CustomElements);\\n\\nwindow.CustomElements.addModule(function(scope) {\\n  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : \\\"none\\\";\\n  function forSubtree(node, cb) {\\n    findAllElements(node, function(e) {\\n      if (cb(e)) {\\n        return true;\\n      }\\n      forRoots(e, cb);\\n    });\\n    forRoots(node, cb);\\n  }\\n  function findAllElements(node, find, data) {\\n    var e = node.firstElementChild;\\n    if (!e) {\\n      e = node.firstChild;\\n      while (e && e.nodeType !== Node.ELEMENT_NODE) {\\n        e = e.nextSibling;\\n      }\\n    }\\n    while (e) {\\n      if (find(e, data) !== true) {\\n        findAllElements(e, find, data);\\n      }\\n      e = e.nextElementSibling;\\n    }\\n    return null;\\n  }\\n  function forRoots(node, cb) {\\n    var root = node.shadowRoot;\\n    while (root) {\\n      forSubtree(root, cb);\\n      root = root.olderShadowRoot;\\n    }\\n  }\\n  function forDocumentTree(doc, cb) {\\n    _forDocumentTree(doc, cb, []);\\n  }\\n  function _forDocumentTree(doc, cb, processingDocuments) {\\n    doc = window.wrap(doc);\\n    if (processingDocuments.indexOf(doc) >= 0) {\\n      return;\\n    }\\n    processingDocuments.push(doc);\\n    var imports = doc.querySelectorAll(\\\"link[rel=\\\" + IMPORT_LINK_TYPE + \\\"]\\\");\\n    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\\n      if (n.import) {\\n        _forDocumentTree(n.import, cb, processingDocuments);\\n      }\\n    }\\n    cb(doc);\\n  }\\n  scope.forDocumentTree = forDocumentTree;\\n  scope.forSubtree = forSubtree;\\n});\\n\\nwindow.CustomElements.addModule(function(scope) {\\n  var flags = scope.flags;\\n  var forSubtree = scope.forSubtree;\\n  var forDocumentTree = scope.forDocumentTree;\\n  function addedNode(node, isAttached) {\\n    return added(node, isAttached) || addedSubtree(node, isAttached);\\n  }\\n  function added(node, isAttached) {\\n    if (scope.upgrade(node, isAttached)) {\\n      return true;\\n    }\\n    if (isAttached) {\\n      attached(node);\\n    }\\n  }\\n  function addedSubtree(node, isAttached) {\\n    forSubtree(node, function(e) {\\n      if (added(e, isAttached)) {\\n        return true;\\n      }\\n    });\\n  }\\n  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags[\\\"throttle-attached\\\"];\\n  scope.hasPolyfillMutations = hasThrottledAttached;\\n  scope.hasThrottledAttached = hasThrottledAttached;\\n  var isPendingMutations = false;\\n  var pendingMutations = [];\\n  function deferMutation(fn) {\\n    pendingMutations.push(fn);\\n    if (!isPendingMutations) {\\n      isPendingMutations = true;\\n      setTimeout(takeMutations);\\n    }\\n  }\\n  function takeMutations() {\\n    isPendingMutations = false;\\n    var $p = pendingMutations;\\n    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\\n      p();\\n    }\\n    pendingMutations = [];\\n  }\\n  function attached(element) {\\n    if (hasThrottledAttached) {\\n      deferMutation(function() {\\n        _attached(element);\\n      });\\n    } else {\\n      _attached(element);\\n    }\\n  }\\n  function _attached(element) {\\n    if (element.__upgraded__ && !element.__attached) {\\n      element.__attached = true;\\n      if (element.attachedCallback) {\\n        element.attachedCallback();\\n      }\\n    }\\n  }\\n  function detachedNode(node) {\\n    detached(node);\\n    forSubtree(node, function(e) {\\n      detached(e);\\n    });\\n  }\\n  function detached(element) {\\n    if (hasThrottledAttached) {\\n      deferMutation(function() {\\n        _detached(element);\\n      });\\n    } else {\\n      _detached(element);\\n    }\\n  }\\n  function _detached(element) {\\n    if (element.__upgraded__ && element.__attached) {\\n      element.__attached = false;\\n      if (element.detachedCallback) {\\n        element.detachedCallback();\\n      }\\n    }\\n  }\\n  function inDocument(element) {\\n    var p = element;\\n    var doc = window.wrap(document);\\n    while (p) {\\n      if (p == doc) {\\n        return true;\\n      }\\n      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\\n    }\\n  }\\n  function watchShadow(node) {\\n    if (node.shadowRoot && !node.shadowRoot.__watched) {\\n      flags.dom && console.log(\\\"watching shadow-root for: \\\", node.localName);\\n      var root = node.shadowRoot;\\n      while (root) {\\n        observe(root);\\n        root = root.olderShadowRoot;\\n      }\\n    }\\n  }\\n  function handler(root, mutations) {\\n    if (flags.dom) {\\n      var mx = mutations[0];\\n      if (mx && mx.type === \\\"childList\\\" && mx.addedNodes) {\\n        if (mx.addedNodes) {\\n          var d = mx.addedNodes[0];\\n          while (d && d !== document && !d.host) {\\n            d = d.parentNode;\\n          }\\n          var u = d && (d.URL || d._URL || d.host && d.host.localName) || \\\"\\\";\\n          u = u.split(\\\"/?\\\").shift().split(\\\"/\\\").pop();\\n        }\\n      }\\n      console.group(\\\"mutations (%d) [%s]\\\", mutations.length, u || \\\"\\\");\\n    }\\n    var isAttached = inDocument(root);\\n    mutations.forEach(function(mx) {\\n      if (mx.type === \\\"childList\\\") {\\n        forEach(mx.addedNodes, function(n) {\\n          if (!n.localName) {\\n            return;\\n          }\\n          addedNode(n, isAttached);\\n        });\\n        forEach(mx.removedNodes, function(n) {\\n          if (!n.localName) {\\n            return;\\n          }\\n          detachedNode(n);\\n        });\\n      }\\n    });\\n    flags.dom && console.groupEnd();\\n  }\\n  function takeRecords(node) {\\n    node = window.wrap(node);\\n    if (!node) {\\n      node = window.wrap(document);\\n    }\\n    while (node.parentNode) {\\n      node = node.parentNode;\\n    }\\n    var observer = node.__observer;\\n    if (observer) {\\n      handler(node, observer.takeRecords());\\n      takeMutations();\\n    }\\n  }\\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\\n  function observe(inRoot) {\\n    if (inRoot.__observer) {\\n      return;\\n    }\\n    var observer = new MutationObserver(handler.bind(this, inRoot));\\n    observer.observe(inRoot, {\\n      childList: true,\\n      subtree: true\\n    });\\n    inRoot.__observer = observer;\\n  }\\n  function upgradeDocument(doc) {\\n    doc = window.wrap(doc);\\n    flags.dom && console.group(\\\"upgradeDocument: \\\", doc.baseURI.split(\\\"/\\\").pop());\\n    var isMainDocument = doc === window.wrap(document);\\n    addedNode(doc, isMainDocument);\\n    observe(doc);\\n    flags.dom && console.groupEnd();\\n  }\\n  function upgradeDocumentTree(doc) {\\n    forDocumentTree(doc, upgradeDocument);\\n  }\\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\\n  if (originalCreateShadowRoot) {\\n    Element.prototype.createShadowRoot = function() {\\n      var root = originalCreateShadowRoot.call(this);\\n      window.CustomElements.watchShadow(this);\\n      return root;\\n    };\\n  }\\n  scope.watchShadow = watchShadow;\\n  scope.upgradeDocumentTree = upgradeDocumentTree;\\n  scope.upgradeDocument = upgradeDocument;\\n  scope.upgradeSubtree = addedSubtree;\\n  scope.upgradeAll = addedNode;\\n  scope.attached = attached;\\n  scope.takeRecords = takeRecords;\\n});\\n\\nwindow.CustomElements.addModule(function(scope) {\\n  var flags = scope.flags;\\n  function upgrade(node, isAttached) {\\n    if (node.localName === \\\"template\\\") {\\n      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\\n        HTMLTemplateElement.decorate(node);\\n      }\\n    }\\n    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\\n      var is = node.getAttribute(\\\"is\\\");\\n      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);\\n      if (definition) {\\n        if (is && definition.tag == node.localName || !is && !definition.extends) {\\n          return upgradeWithDefinition(node, definition, isAttached);\\n        }\\n      }\\n    }\\n  }\\n  function upgradeWithDefinition(element, definition, isAttached) {\\n    flags.upgrade && console.group(\\\"upgrade:\\\", element.localName);\\n    if (definition.is) {\\n      element.setAttribute(\\\"is\\\", definition.is);\\n    }\\n    implementPrototype(element, definition);\\n    element.__upgraded__ = true;\\n    created(element);\\n    if (isAttached) {\\n      scope.attached(element);\\n    }\\n    scope.upgradeSubtree(element, isAttached);\\n    flags.upgrade && console.groupEnd();\\n    return element;\\n  }\\n  function implementPrototype(element, definition) {\\n    if (Object.__proto__) {\\n      element.__proto__ = definition.prototype;\\n    } else {\\n      customMixin(element, definition.prototype, definition.native);\\n      element.__proto__ = definition.prototype;\\n    }\\n  }\\n  function customMixin(inTarget, inSrc, inNative) {\\n    var used = {};\\n    var p = inSrc;\\n    while (p !== inNative && p !== HTMLElement.prototype) {\\n      var keys = Object.getOwnPropertyNames(p);\\n      for (var i = 0, k; k = keys[i]; i++) {\\n        if (!used[k]) {\\n          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\\n          used[k] = 1;\\n        }\\n      }\\n      p = Object.getPrototypeOf(p);\\n    }\\n  }\\n  function created(element) {\\n    if (element.createdCallback) {\\n      element.createdCallback();\\n    }\\n  }\\n  scope.upgrade = upgrade;\\n  scope.upgradeWithDefinition = upgradeWithDefinition;\\n  scope.implementPrototype = implementPrototype;\\n});\\n\\nwindow.CustomElements.addModule(function(scope) {\\n  var isIE = scope.isIE;\\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\\n  var upgradeAll = scope.upgradeAll;\\n  var upgradeWithDefinition = scope.upgradeWithDefinition;\\n  var implementPrototype = scope.implementPrototype;\\n  var useNative = scope.useNative;\\n  function register(name, options) {\\n    var definition = options || {};\\n    if (!name) {\\n      throw new Error(\\\"document.registerElement: first argument `name` must not be empty\\\");\\n    }\\n    if (name.indexOf(\\\"-\\\") < 0) {\\n      throw new Error(\\\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\\\" + String(name) + \\\"'.\\\");\\n    }\\n    if (isReservedTag(name)) {\\n      throw new Error(\\\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\\\" + String(name) + \\\"'. The type name is invalid.\\\");\\n    }\\n    if (getRegisteredDefinition(name)) {\\n      throw new Error(\\\"DuplicateDefinitionError: a type with name '\\\" + String(name) + \\\"' is already registered\\\");\\n    }\\n    if (!definition.prototype) {\\n      definition.prototype = Object.create(HTMLElement.prototype);\\n    }\\n    definition.__name = name.toLowerCase();\\n    if (definition.extends) {\\n      definition.extends = definition.extends.toLowerCase();\\n    }\\n    definition.lifecycle = definition.lifecycle || {};\\n    definition.ancestry = ancestry(definition.extends);\\n    resolveTagName(definition);\\n    resolvePrototypeChain(definition);\\n    overrideAttributeApi(definition.prototype);\\n    registerDefinition(definition.__name, definition);\\n    definition.ctor = generateConstructor(definition);\\n    definition.ctor.prototype = definition.prototype;\\n    definition.prototype.constructor = definition.ctor;\\n    if (scope.ready) {\\n      upgradeDocumentTree(document);\\n    }\\n    return definition.ctor;\\n  }\\n  function overrideAttributeApi(prototype) {\\n    if (prototype.setAttribute._polyfilled) {\\n      return;\\n    }\\n    var setAttribute = prototype.setAttribute;\\n    prototype.setAttribute = function(name, value) {\\n      changeAttribute.call(this, name, value, setAttribute);\\n    };\\n    var removeAttribute = prototype.removeAttribute;\\n    prototype.removeAttribute = function(name) {\\n      changeAttribute.call(this, name, null, removeAttribute);\\n    };\\n    prototype.setAttribute._polyfilled = true;\\n  }\\n  function changeAttribute(name, value, operation) {\\n    name = name.toLowerCase();\\n    var oldValue = this.getAttribute(name);\\n    operation.apply(this, arguments);\\n    var newValue = this.getAttribute(name);\\n    if (this.attributeChangedCallback && newValue !== oldValue) {\\n      this.attributeChangedCallback(name, oldValue, newValue);\\n    }\\n  }\\n  function isReservedTag(name) {\\n    for (var i = 0; i < reservedTagList.length; i++) {\\n      if (name === reservedTagList[i]) {\\n        return true;\\n      }\\n    }\\n  }\\n  var reservedTagList = [ \\\"annotation-xml\\\", \\\"color-profile\\\", \\\"font-face\\\", \\\"font-face-src\\\", \\\"font-face-uri\\\", \\\"font-face-format\\\", \\\"font-face-name\\\", \\\"missing-glyph\\\" ];\\n  function ancestry(extnds) {\\n    var extendee = getRegisteredDefinition(extnds);\\n    if (extendee) {\\n      return ancestry(extendee.extends).concat([ extendee ]);\\n    }\\n    return [];\\n  }\\n  function resolveTagName(definition) {\\n    var baseTag = definition.extends;\\n    for (var i = 0, a; a = definition.ancestry[i]; i++) {\\n      baseTag = a.is && a.tag;\\n    }\\n    definition.tag = baseTag || definition.__name;\\n    if (baseTag) {\\n      definition.is = definition.__name;\\n    }\\n  }\\n  function resolvePrototypeChain(definition) {\\n    if (!Object.__proto__) {\\n      var nativePrototype = HTMLElement.prototype;\\n      if (definition.is) {\\n        var inst = document.createElement(definition.tag);\\n        nativePrototype = Object.getPrototypeOf(inst);\\n      }\\n      var proto = definition.prototype, ancestor;\\n      var foundPrototype = false;\\n      while (proto) {\\n        if (proto == nativePrototype) {\\n          foundPrototype = true;\\n        }\\n        ancestor = Object.getPrototypeOf(proto);\\n        if (ancestor) {\\n          proto.__proto__ = ancestor;\\n        }\\n        proto = ancestor;\\n      }\\n      if (!foundPrototype) {\\n        console.warn(definition.tag + \\\" prototype not found in prototype chain for \\\" + definition.is);\\n      }\\n      definition.native = nativePrototype;\\n    }\\n  }\\n  function instantiate(definition) {\\n    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\\n  }\\n  var registry = {};\\n  function getRegisteredDefinition(name) {\\n    if (name) {\\n      return registry[name.toLowerCase()];\\n    }\\n  }\\n  function registerDefinition(name, definition) {\\n    registry[name] = definition;\\n  }\\n  function generateConstructor(definition) {\\n    return function() {\\n      return instantiate(definition);\\n    };\\n  }\\n  var HTML_NAMESPACE = \\\"http://www.w3.org/1999/xhtml\\\";\\n  function createElementNS(namespace, tag, typeExtension) {\\n    if (namespace === HTML_NAMESPACE) {\\n      return createElement(tag, typeExtension);\\n    } else {\\n      return domCreateElementNS(namespace, tag);\\n    }\\n  }\\n  function createElement(tag, typeExtension) {\\n    if (tag) {\\n      tag = tag.toLowerCase();\\n    }\\n    if (typeExtension) {\\n      typeExtension = typeExtension.toLowerCase();\\n    }\\n    var definition = getRegisteredDefinition(typeExtension || tag);\\n    if (definition) {\\n      if (tag == definition.tag && typeExtension == definition.is) {\\n        return new definition.ctor();\\n      }\\n      if (!typeExtension && !definition.is) {\\n        return new definition.ctor();\\n      }\\n    }\\n    var element;\\n    if (typeExtension) {\\n      element = createElement(tag);\\n      element.setAttribute(\\\"is\\\", typeExtension);\\n      return element;\\n    }\\n    element = domCreateElement(tag);\\n    if (tag.indexOf(\\\"-\\\") >= 0) {\\n      implementPrototype(element, HTMLElement);\\n    }\\n    return element;\\n  }\\n  var domCreateElement = document.createElement.bind(document);\\n  var domCreateElementNS = document.createElementNS.bind(document);\\n  var isInstance;\\n  if (!Object.__proto__ && !useNative) {\\n    isInstance = function(obj, ctor) {\\n      if (obj instanceof ctor) {\\n        return true;\\n      }\\n      var p = obj;\\n      while (p) {\\n        if (p === ctor.prototype) {\\n          return true;\\n        }\\n        p = p.__proto__;\\n      }\\n      return false;\\n    };\\n  } else {\\n    isInstance = function(obj, base) {\\n      return obj instanceof base;\\n    };\\n  }\\n  function wrapDomMethodToForceUpgrade(obj, methodName) {\\n    var orig = obj[methodName];\\n    obj[methodName] = function() {\\n      var n = orig.apply(this, arguments);\\n      upgradeAll(n);\\n      return n;\\n    };\\n  }\\n  wrapDomMethodToForceUpgrade(Node.prototype, \\\"cloneNode\\\");\\n  wrapDomMethodToForceUpgrade(document, \\\"importNode\\\");\\n  document.registerElement = register;\\n  document.createElement = createElement;\\n  document.createElementNS = createElementNS;\\n  scope.registry = registry;\\n  scope.instanceof = isInstance;\\n  scope.reservedTagList = reservedTagList;\\n  scope.getRegisteredDefinition = getRegisteredDefinition;\\n  document.register = document.registerElement;\\n});\\n\\n(function(scope) {\\n  var useNative = scope.useNative;\\n  var initializeModules = scope.initializeModules;\\n  var isIE = scope.isIE;\\n  if (useNative) {\\n    var nop = function() {};\\n    scope.watchShadow = nop;\\n    scope.upgrade = nop;\\n    scope.upgradeAll = nop;\\n    scope.upgradeDocumentTree = nop;\\n    scope.upgradeSubtree = nop;\\n    scope.takeRecords = nop;\\n    scope.instanceof = function(obj, base) {\\n      return obj instanceof base;\\n    };\\n  } else {\\n    initializeModules();\\n  }\\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\\n  var upgradeDocument = scope.upgradeDocument;\\n  if (!window.wrap) {\\n    if (window.ShadowDOMPolyfill) {\\n      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\\n      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\\n    } else {\\n      window.wrap = window.unwrap = function(node) {\\n        return node;\\n      };\\n    }\\n  }\\n  if (window.HTMLImports) {\\n    window.HTMLImports.__importsParsingHook = function(elt) {\\n      if (elt.import) {\\n        upgradeDocument(wrap(elt.import));\\n      }\\n    };\\n  }\\n  function bootstrap() {\\n    upgradeDocumentTree(window.wrap(document));\\n    window.CustomElements.ready = true;\\n    var requestAnimationFrame = window.requestAnimationFrame || function(f) {\\n      setTimeout(f, 16);\\n    };\\n    requestAnimationFrame(function() {\\n      setTimeout(function() {\\n        window.CustomElements.readyTime = Date.now();\\n        if (window.HTMLImports) {\\n          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\\n        }\\n        document.dispatchEvent(new CustomEvent(\\\"WebComponentsReady\\\", {\\n          bubbles: true\\n        }));\\n      });\\n    });\\n  }\\n  if (document.readyState === \\\"complete\\\" || scope.flags.eager) {\\n    bootstrap();\\n  } else if (document.readyState === \\\"interactive\\\" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\\n    bootstrap();\\n  } else {\\n    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? \\\"HTMLImportsLoaded\\\" : \\\"DOMContentLoaded\\\";\\n    window.addEventListener(loadEvent, bootstrap);\\n  }\\n})(window.CustomElements);\\n\\n(function(scope) {\\n  if (!Function.prototype.bind) {\\n    Function.prototype.bind = function(scope) {\\n      var self = this;\\n      var args = Array.prototype.slice.call(arguments, 1);\\n      return function() {\\n        var args2 = args.slice();\\n        args2.push.apply(args2, arguments);\\n        return self.apply(scope, args2);\\n      };\\n    };\\n  }\\n})(window.WebComponents);\\n\\n(function(scope) {\\n  var style = document.createElement(\\\"style\\\");\\n  style.textContent = \\\"\\\" + \\\"body {\\\" + \\\"transition: opacity ease-in 0.2s;\\\" + \\\" } \\\\n\\\" + \\\"body[unresolved] {\\\" + \\\"opacity: 0; display: block; overflow: hidden; position: relative;\\\" + \\\" } \\\\n\\\";\\n  var head = document.querySelector(\\\"head\\\");\\n  head.insertBefore(style, head.firstChild);\\n})(window.WebComponents);\\n\\n(function(scope) {\\n  window.Platform = scope;\\n})(window.WebComponents);\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/webcomponents.js/webcomponents.js\n// module id = 511\n// module chunks = 3","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader/addScript.js\n// module id = 529\n// module chunks = 3"],"sourceRoot":""}